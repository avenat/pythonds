..  Copyright (C)  Brad Miller, David Ranum, Jeffrey Elkner, Peter Wentworth, Allen B. Downey, Chris
    Meyers, and Dario Mitchell.  Permission is granted to copy, distribute
    and/or modify this document under the terms of the GNU Free Documentation
    License, Version 1.3 or any later version published by the Free Software
    Foundation; with Invariant Sections being Forward, Prefaces, and
    Contributor List, no Front-Cover Texts, and no Back-Cover Texts.  A copy of
    the license is included in the section entitled "GNU Free Documentation
    License".

Нотация "большое О"
~~~~~~~~~~~~~~

При попытке охарактеризовать эффективность алгоритма в терминах времени
выполнения независимо от конкретной программы или компьютера, очень важно
оценить количество операций или шагов, которые потребуются алгоритму. Если
каждый из этих шагов принять за базовую единицу вычисления, то время
выполнения алгоритма может быть выражено, как количество шагов, требуемых
для решения задачи. Принятие решение о том, что же является таким базовым
блоком вычисления, может быть сложной задачей, зависящей от того, как
алгоритм реализован.

Хорошей базовой единицей вычисления для сравнения суммирующих алгоритмов,
показанных ранее, может служить количество операций присваивания,
используемых при подсчёте суммы. В функции sumOfN есть только одно такое
присваивание 1 (:math:`theSum = 0`) плюс значение n (сколько раз мы вычисляем
:math:`theSum=theSum+i`). Мы можем обозначить эту величину (назовём её T),
где :math:`T(n)=1 + n`. Параметр n часто называют "размером задания", так что
мы можем прочитать это как "T(n) - это время, необходимое для решения задачи,
размером n, за 1+n шагов."

В представленных выше функциях суммирования для обозначения размера задачи
имеет смысл использовать количество слагаемых. Так мы сможем сказать, что
суммирование первых 100 000 целых - задание большее, чем суммирование первой
тысячи. Поэтому выглядит разумным положение, что время, требуемое на решение
большего случая, будет больше, чем для меньшего случая. Таким образом, наша
цель - показать, как время работы алгоритма изменяется в зависимости от
размера задачи.

Учёные-информатики при использовании такой техники анализа предпочитают
идти на один шаг дальше. Выходит так, что точное количество операций не
так важно, как определение наиболее доминирующей части функции :math:`T(n)`.
Другими словами, когда задание становится больше, некая часть функции
:math:`T(n)`, как правило, перекрывает всё остальное. Эта доминирующая
часть в итоге и используется при сравнении. Функция **порядка величины**
описывает ту часть :math:`T(n)`, которая сильнее возрастает при росте *n*.
Порядок величины часто называют нотацией **"большое О"** (от order - порядок)
и записывают как :math:`O(f(n))`. Он предоставляет целесообразное приближение
к действительному числу шагов в вычислении. Функция :math:`f(n)` является
простым представлением доминирующей части оригинальной :math:`T(n)`.

В примере выше :math:`T(n)=1+n`. Чем больше становится *n*, тем менее значимой
для конечного результата становится константа 1. При поиске приближения для
:math:`T(n)` мы можем отбросить 1 и просто сказать, что временем выполнения
является :math:`O(n)`. Важно отметить, что 1 безусловно важна для :math:`T(n)`.
Однако, при росте *n* наше приближение останется столь же точным и без неё.

Ещё один пример: предположим, что для некоего алгоритма точное число шагов
:math:`T(n)=5n^{2}+27n+1005`. При малых *n* (скажем, 1 или 2) константа 1005
выглядит доминирующей частью функции. Однако, с ростом *n*, превалирующим
становится слагаемое :math:`n^{2}`. Фактически, когда *n* действительно велико,
то два других слагаемых перестают играть хоть какую-нибудь значимую роль в
определении конечного результата. Ещё раз, аппроксимируя :math:`T(n)` с ростом
*n*, мы можем игнорировать другие слагаемые и сфокусироваться только на
:math:`5n^{2}`. Дополнительно, коэффициент :math:`5` тоже становится неважным
при увеличении *n*. Так что мы можем сказать, что функция :math:`T(n)` имеет
порядок величины :math:`f(n)=n^{2}`, или просто :math:`O(n^{2})`.

Хотя мы и не видим этого в примере с суммированием, иногда производительность
алгоритма зависит от точных значений данных больше, чем от размера задачи. Для
алгоритмов такого рода нам нужно характеризовать их эффективность с точки зрения
наилучшего, наихудшего или усреднённого случая. Производительность для худшего
случая относится к определённому набору данных, на котором алгоритм выполняется
особенно плохо. В то время как различные наборы данных для точно такого же
алгоритма могут иметь необычайно хорошую производительность, в большинстве случаев
алгоритм имеет производительность где-то по середине между этими двумя экстремумами
(усреднённый случай). Учёным-информатикам важно понимать эти различия, чтобы на
впасть в заблуждение при рассмотрении одного конкретного случая.

Некоторое количество очень распространённых функций порядка величины будет попадаться
вам вновь и вновь в процессе изучения алгоритмов. Все они представлены в
:ref:`Таблице 1 <tbl_fntable>`. Для того, чтобы увидеть, какая из них является
доминирующей частью любое функции :math:`T(n)`, мы должны видеть, как они
соотносятся друг с другом при возрастании *n*.

.. _tbl_fntable: 

.. table:: **Таблица 1: Наиболее распространённые функции для "большого О"**

    ================= ========================
             **f(n)**       **Название**
    ================= ========================
          :math:`1`                Константная
     :math:`\log n`            Логарифмическая
          :math:`n`                   Линейная
    :math:`n\log n`    Линейно-логарифмическая
      :math:`n^{2}`               Квадратичная
      :math:`n^{3}`                 Кубическая
      :math:`2^{n}`           Экспоненциальная
    ================= ========================


На :ref:`Рисунке 1 <fig_graphfigure>` показаны графики распространённых
функций из :ref:`Таблицы 1 <tbl_fntable>`. Обратите внимание, что при малых
*n* функции нелегко отличить друг от друга и тяжело сказать, какая из них
доминирует. Однако, как только *n* вырастает, появляется определённая
зависимость, и легко увидеть, как они соотносятся друг с другом.


.. _fig_graphfigure:

.. figure:: Figures/newplot.png

   Рисунок 1: Графики распространённых функций "большое О"


В качестве заключительного примера предположим, что у нас есть фрагмент кода на
Python, показанный в :ref:`Листинге 2 <lst_dummycode>`. Несмотря на то, что на
самом деле эта программа ничего не делает, полезно будет посмотреть, как мы можем
взять существующий код и проанализировать его производительность.


.. _lst_dummycode:

**Листинг 2**

::

    a=5
    b=6
    c=10
    for i in range(n):
       for j in range(n):
          x = i * i
          y = j * j
          z = i * j
    for k in range(n):
       w = a*k + 45
       v = b*b
    d = 33

Число операций присваивания представляет собой сумму из четырёх слагаемых.
Первое - константа 3, представляющая три присваивания в начале фрагмента.
Второе - :math:`3n^{2}`, поскольку три присваивания выполняются :math:`n^{2}`
раз внутри вложенной итерации. Третье - :math:`2n`, два присваивания,
повторяющиеся *n* раз. Наконец, четвёртое слагаемое - константа 1, представляющая
последний оператор присваивания. Всё вместе это даёт
:math:`T(n)=3+3n^{2}+2n+1=3n^{2}+2n+4`. Глядя на степени, мы легко можем заметить,
что слагаемое :math:`n^{2}` будет доминантой, и следовательно, этот фрагмент кода
является :math:`O(n^{2})`. Обратите внимание, что прочие слагаемые (так же, как и
коэффициенты) можно проигнорировать при возрастании *n*.


.. _fig_graphfigure2:

.. figure:: Figures/newplot2.png

   Рисунок 2: Сравнение :math:`T(n)` с распространёнными функциями "большого О"


На :ref:`Рисунке 2 <fig_graphfigure2>` показаны графики нескольких распространённых
функций "большое О" в сравнении с обсуждаемой выше функцией :math:`T(n)`. Обратите
внимание, что в изначально :math:`T(n)` больше, чем кубическая функция, но с ростом *n*
последняя быстро берёт верх над :math:`T(n)` Так же легко увидеть, что :math:`T(n)` с
ростом :math:`n` следует квадратичной функции.


.. admonition:: Самопроверка

   Напишите на Python две функции для поиска минимального значения в списке. Первая из них должна сравнивать каждое число со всеми другими значениями в списке. :math:`O(n^2)`. Вторая функция должна быть линейной с :math:`O(n)`


.. video::  findMinVid
   :controls:
   :thumb: ../_static/function_intro.png

   http://media.interactivepython.org/pythondsVideos/findmin.mov
   http://media.interactivepython.org/pythondsVideos/findmin.webm
