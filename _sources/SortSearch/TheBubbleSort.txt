..  Copyright (C)  Brad Miller, David Ranum, Jeffrey Elkner, Peter Wentworth, Allen B. Downey, Chris
    Meyers, and Dario Mitchell.  Permission is granted to copy, distribute
    and/or modify this document under the terms of the GNU Free Documentation
    License, Version 1.3 or any later version published by the Free Software
    Foundation; with Invariant Sections being Forward, Prefaces, and
    Contributor List, no Front-Cover Texts, and no Back-Cover Texts.  A copy of
    the license is included in the section entitled "GNU Free Documentation
    License".

Пузырьковая сортировка
~~~~~~~~~~~~~~~~~~~~~~~

**Пузырьковая сортировка** делает по списку несколько проходов. Она сравнивает стоящие рядом элементы и меняет местами те из них, что находятся в неправильном порядке. Каждый проход по списку помещает следующее наибольшее значение на его правильную позицию. В сущности, каждый элемент "пузырьком" всплывает на своё место.

:ref:`Рисунок 1 <fig_bubblepass>` показывает первый проход пузырьковой сортировки. Затенёные элементы будут сравниваться для определения в правильном ли порядке они стоят. Если в списке *n* элементов, то за первый проход потребуется сравнить :math:`n-1` пару. Важно отметить, что поскольку наибольшее значение - часть пары, то оно будет перемещаться вдоль списка до завершения прохода.

.. _fig_bubblepass:

.. figure:: Figures/bubblepass.png
   :align: center

Рисунок 1: ``bubbleSort``: первый проход

К началу второго прохода наибольшее значение стоит на своём месте. Остаётся :math:`n-1` число для сортировки, или :math:`n-2` пары. Поскольку каждый проход помещает следующее наибольшее значение на положенное место, то общее количество проходов равняется :math:`n-1`. После завершения :math:`n-1` прохода наименьший элемент будет на верной позиции без дополнительных вычислений. :ref:`ActiveCode 1 <lst_bubble>` демонстрирует функцию ``bubbleSort`` целиком. Она принимает список в качестве параметра и при необходимости изменяет его с помощью перестановок элементов.

Операция перестановки, иногда называемая "обменом", в Python несколько проще, чем в большинстве других языков программирования. Обычно перестановка местами двух элементов списка требует временного сохранения их местоположения (дополнительный объём памяти). Следующий фрагмент кода

::

    temp = alist[i]
    alist[i] = alist[j]
    alist[j] = temp

меняет местами i-й и j-й элементы списка. Одно из значений будет переписано безо всякого временного хранилища.

В Python возможно одновременное присвоение. Оператор ``a,b = b,a`` даст тот же результат, что и два присвоения, сделанных в одно и то же время (см. :ref:`рисунок 2 <fig_pythonswap>`). С использованием одновременного присваивания операция обмена займёт всего в одну строку.

Строки 5-7 в :ref:`ActiveCode 1 <lst_bubble>` производят обмен :math:`i`-го и :math:`(i+1)`-го элементов, используя трёхступенчатую операцию, описанную выше. Заметьте, что для перестановки элементов мы также можем использовать одновременное присваивание.

.. _fig_pythonswap:

.. figure:: Figures/swap.png
   :align: center

    Рисунок 2: Перестановка местами двух значений в Python

Следующий пример *ActiveCode* демонстрирует законченную функцию ``bubbleSort``, работающую со списком, показанным выше.

.. _lst_bubble:

.. activecode:: lst_bubble
    :caption: Пузырьковая сортировка

    def bubbleSort(alist):
        for passnum in range(len(alist)-1,0,-1):
            for i in range(passnum):
                if alist[i]>alist[i+1]:
                    temp = alist[i]
                    alist[i] = alist[i+1]
                    alist[i+1] = temp

    alist = [54,26,93,17,77,31,44,55,20]
    bubbleSort(alist)
    print(alist)

Следующая анимация показывает ``bubbleSort`` в действии.

.. animation:: bubble_anim
   :modelfile: sortmodels.js
   :viewerfile: sortviewers.js
   :model: BubbleSortModel
   :viewer: BarViewer

Для большей детализации CodeLens позволит вам пройти по алгоритму шаг за шагом.

.. codelens:: bubbletrace
    :caption: Трассировка пузырьковой сортировки
    
    def bubbleSort(alist):
        for passnum in range(len(alist)-1,0,-1):
            for i in range(passnum):
                if alist[i]>alist[i+1]:
                    temp = alist[i]
                    alist[i] = alist[i+1]
                    alist[i+1] = temp
    
    alist = [54,26,93,17,77,31,44,55,20]
    bubbleSort(alist)    
    print(alist) 

При анализе пузырьковой сортировки стоит отметить, что, вне зависимости от первоначального порядка элементов, для списка из *n* элементов будет сделан :math:`n-1` проход. :ref:`Таблица 1 <tbl_bubbleanalysis>` показывает число сравнений при каждом проходе. Общее количество сравнений - сумма первых :math:`n-1` чисел. Напомним, что сумма первых *n* целых равна :math:`\frac{1}{2}n^{2} + \frac{1}{2}n`. Сумма первых :math:`n-1` чисел равна :math:`\frac{1}{2}n^{2} + \frac{1}{2}n - n`, или после сокращения :math:`\frac{1}{2}n^{2} - \frac{1}{2}n`. Т.е. это по-прежнему :math:`O(n^{2})` сравнений. В лучшем случае, когда список уже отсортирован, не будет сделано ни одной перестановки. Однако, для наихудшего случая каждое сравнение повлечёт за собой обмен. В среднем же обмен займёт половину времени.

.. _tbl_bubbleanalysis:

.. table:: **Таблица 1: Сравнения при каждом проходе пузырьковой сортировки**

    ================= ===========================
    **Проход**          **Количество сравнений**
    ================= ===========================
             1         :math:`n-1`
             2         :math:`n-2`
             3         :math:`n-3`
             ...       ...
       :math:`n-1`     :math:`1`
    ================= ===========================

Пузырьковая сортировка часто рассматривается как наиболее неэффективный сортировочный метод, поскольку она должна переставлять элементы до того, как станет известна их окончательная позиция. Эти "пустые" операции обмена весьма затратны. Однако, поскольку пузырьковая сортировка делает проход по всей несортированной части списка, она умеет то, что не могут большинство сортировочных алгоритмов. В частности, если во время прохода не было сделано ни одной перестановки, то мы знаем, что список уже отсортирован. Таким образом, пузырьковая сортировка может быть модифицирована, чтобы останавливаться раньше при обнаружении, что список отсортировался. Т.е. для списков, которым нужно всего несколько проходов, пузырьковая сортировка имеет преимущество, поскольку умеет распознать сортированный список и остановиться.:ref:`ActiveCode 2 <lst_shortbubble>` демонстрирует эту модификацию, которую часто называют **коротким пузырьком**.

.. _lst_shortbubble:

.. activecode:: lst_shortbubble
    :caption: Короткая пузырьковая сортировка

    def shortBubbleSort(alist):
        exchanges = True
        passnum = len(alist)-1
        while passnum > 0 and exchanges:
           exchanges = False
           for i in range(passnum):
               if alist[i]>alist[i+1]:
                   exchanges = True
                   temp = alist[i]
                   alist[i] = alist[i+1]
                   alist[i+1] = temp
           passnum = passnum-1

    alist=[20,30,40,90,50,60,70,80,100,110]
    shortBubbleSort(alist)
    print(alist) 

И, наконец, ``shortBubbleSort`` в CodeLens.

.. codelens:: shortbubbletrace
    :caption: Трассировка короткой пузырьковой сортировки

    def shortBubbleSort(alist):
        exchanges = True
        passnum = len(alist)-1
        while passnum > 0 and exchanges:
           exchanges = False
           for i in range(passnum):
               if alist[i]>alist[i+1]:
                   exchanges = True
                   temp = alist[i]
                   alist[i] = alist[i+1]
                   alist[i+1] = temp
           passnum = passnum-1

    alist=[20,30,40,90,50,60,70,80,100,110]
    shortBubbleSort(alist)
    print(alist) 

.. admonition:: Самопроверка

   .. mchoicemf:: question_sort_1
       :correct: b
       :answer_a: [1, 9, 19, 7, 3, 10, 13, 15, 8, 12]
       :answer_b: [1, 3, 7, 9, 10, 8, 12, 13, 15, 19]
       :answer_c: [1, 7, 3, 9, 10, 13, 8, 12, 15, 19]
       :answer_d: [1, 9, 19, 7, 3, 10, 13, 15, 8, 12]
       :feedback_a:  Этот ответ представляет три перестановки. Проход подразумевает, что вы продолжаете обмены до конца списка.
       :feedback_b:  Очень хорошо.
       :feedback_c: Пузырьковая сортировка продолжает перестановки чисел до позиции с индексом ``passnum``. Не забывайте, что ``passnum`` инициализируется значением (длина_списка - 1).
       :feedback_d: Вы сделали сортировку вставками, а не пузырьковую.

        Предположим, у вас есть следующий список чисел для сортировки: [19, 1, 9, 7, 3, 10, 13, 15, 8, 12]. Какой из следующих списков представляет собой частично отсортированный список после трёх проходов пузырьковой сортировки?
