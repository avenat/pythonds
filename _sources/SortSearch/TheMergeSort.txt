..  Copyright (C)  Brad Miller, David Ranum, Jeffrey Elkner, Peter Wentworth, Allen B. Downey, Chris
    Meyers, and Dario Mitchell.  Permission is granted to copy, distribute
    and/or modify this document under the terms of the GNU Free Documentation
    License, Version 1.3 or any later version published by the Free Software
    Foundation; with Invariant Sections being Forward, Prefaces, and
    Contributor List, no Front-Cover Texts, and no Back-Cover Texts.  A copy of
    the license is included in the section entitled "GNU Free Documentation
    License".

Сортировка слиянием
~~~~~~~~~~~~~~~~~~~~

Теперь обратим наше внимание на использование стратегии "разделяй и властвуй", как способа улучшить производительность сортировочных алгоритмов. Первым из них станет **сортировка слиянием**. Это рекурсивный алгоритм, который постоянно разбивает список пополам. Если список пуст или состоит из одного элемента, то он отсортирован по определению (базовый случай). Если в списке больше, чем один элемент, мы разбиваем его и рекурсивно вызываем сортировку слиянием для каждой из половин. После того, как обе они уже отсортированы, выполняется основная операция, называемая **слиянием**. Слияние - это процесс комбинирования двух меньших сортированных списков в один новый, но тоже отсортированный. :ref:`Рисунок 10 <fig_mergesortA>` демонстрирует в качестве примера старый знакомый список, который начинают разбивать с помощью ``mergeSort``. :ref:`Рисунок 11 <fig_mergesortB>` показывает отсортированные списки и их слияние вместе.

. _fig_mergesortA:

.. figure:: Figures/mergesortA.png
   :align: center

    Рисунок 10: Разбиение списка в сортировке слиянием

.. _fig_mergesortB:

.. figure:: Figures/mergesortB.png
   :align: center

    Рисунок 11: Списки, которые соединяются вместе

Функция ``mergeSort``, показанная в :ref:`ActiveCode 6 <lst_merge>`, начинает с проверки базового условия. Если длина списка меньше или равна единице, то он уже отсортирован, и в дальшейшей обработке нет необходимости. С другой стороны, если длина больше единицы, то мы используем операцию Python ``slice``, чтобы извлечь правую и левую части. Важно отметить, что список может иметь нечётное количество элементов. Для алгоритма это не принципиально, поскольку длины будут различаться максимум на единицу.

.. _lst_merge:

.. activecode:: lst_merge
    :caption: Сортировка слиянием

    def mergeSort(alist):
        print("Splitting ",alist)
        if len(alist)>1:
            mid = len(alist)//2
            lefthalf = alist[:mid]
            righthalf = alist[mid:]

            mergeSort(lefthalf)
            mergeSort(righthalf)

            i=0
            j=0
            k=0
            while i<len(lefthalf) and j<len(righthalf):
                if lefthalf[i]<righthalf[j]:
                    alist[k]=lefthalf[i]
                    i=i+1
                else:
                    alist[k]=righthalf[j]
                    j=j+1
                k=k+1

            while i<len(lefthalf):
                alist[k]=lefthalf[i]
                i=i+1
                k=k+1

            while j<len(righthalf):
                alist[k]=righthalf[j]
                j=j+1
                k=k+1
        print("Merging ",alist)
        
    alist = [54,26,93,17,77,31,44,55,20]
    mergeSort(alist)
    print(alist) 

После того, как функция ``mergeSort`` была вызывана для правой и левой частей (строки 8 - 9), предполагается, что они отсортированы. Остаток функции (строки 11 - 31) отвечает за слияние двух меньших сортированных списков в больший. Обратите внимание, что операция слияния помещает элементы обратно в оригинальный список (``alist``) по одному за раз с помощью повторяющегося выбора наименьшего элемента из двух сортированных списков.

Функцию ``mergeSort`` дополняет оператор ``print`` (строка 2), который выводит содержимое сортируемого списка на начало каждого вызова. Также есть оператор ``print`` (строка 32), показывающий процесс слияния. Результат вычисления функции на нашем примере списка выводится на экран. Обратите внимание, что список с 44, 55 и 20 не делится поровну. Первая его часть равна [44], а вторая - [55, 20]. Легко увидеть, как процесс разбивки в итоге приводит к тому, что список может быть немедленно слит с другими сортированными списками.

.. animation:: merge_anim
   :modelfile: sortmodels.js
   :viewerfile: sortviewers.js
   :model: MergeSortModel
   :viewer: BarViewer

Для большей детализации, CodeLens позволят вам пошагово пройти весь алгоритм.

.. codelens:: mergetrace
    :caption: Трассировка сортировки слиянием

    def mergeSort(alist):
        print("Splitting ",alist)
        if len(alist)>1:
            mid = len(alist)//2
            lefthalf = alist[:mid]
            righthalf = alist[mid:]

            mergeSort(lefthalf)
            mergeSort(righthalf)

            i=0
            j=0
            k=0
            while i<len(lefthalf) and j<len(righthalf):
                if lefthalf[i]<righthalf[j]:
                    alist[k]=lefthalf[i]
                    i=i+1
                else:
                    alist[k]=righthalf[j]
                    j=j+1
                k=k+1

            while i<len(lefthalf):
                alist[k]=lefthalf[i]
                i=i+1
                k=k+1

            while j<len(righthalf):
                alist[k]=righthalf[j]
                j=j+1
                k=k+1
        print("Merging ",alist)
        
    alist = [54,26,93,17,77,31,44,55,20]
    mergeSort(alist)
    print(alist) 

Чтобы проанализировать функцию ``megreSort``, нам надо рассмотреть два различных процесса, которые составляют её реализацию. Во-первых, список разбивается пополам. Мы уже вычисляли (для бинарного поиска), что разделять список на две половины можно :math:`\log n` раз, где *n* - длина списка. Второй процесс - это слияние. Каждый элемент будет обработан и помещён в сортированный список. Таким образом, операция слияния, чей результат - список из *n* элементов, потребует *n* операций. Итог данного анализа: :math:`\log n` разбиений, каждое стоимостью :math:`n`, в сумме даст :math:`n\log n` операций. Таким образом, сортировка слиянием :math:`O(n\log n)` алгоритм.

Напомним, что встроенный оператор разбиения имеет :math:`O(k)`, где k - размер разбиения. С целью гарантировать :math:`O(n\log n)` для сортировки слиянием, нам нужно от него избавиться. Напомним, что это возможно, если просто помещать начальный и конечный индексы вместе со списком в качестве аргументов рекурсивного вызова. Мы оставляем это вам в качестве упражнения.

Важно отметить, что функция ``mergeSort`` требует дополнительного места для хранения двух извлечённых операцией разбиения частей. Это дополнительное пространство может стать критичным фактором, если список велик, и сделать этот способ сортировки проблемным для больших наборов данных.

.. admonition:: Самопроверка
   .. mchoicemf:: question_sort_5
      :correct: b
      :answer_a: [16, 49, 39, 27, 43, 34, 46, 40]
      :answer_b: [21,1]
      :answer_c: [21, 1, 26, 45]
      :answer_d: [21]
      :feedback_a: Это вторая часть списка.
      :feedback_b: Верно, сортировка слиянием будет продолжать рекурсчивно перемещаться к началу списка, пока не достигнет базового случая.
      :feedback_c: Не забывайте, сортировка слиянием не работает с правой половиной списка, пока полностью не отсортирует левую.
      :feedback_d: Это список после четырёх рекурсивных вызовов.

      Дан следующий список чисел: [21, 1, 26, 45, 29, 28, 2, 9, 16, 49, 39, 27, 43, 34, 46, 40]. Который из ответов иллюстрирует список после трёх рекурсивных вызовов сортировки слиянием?

   .. mchoicemf:: question_sort_6
      :correct: c
      :answer_a: [21, 1] and [26, 45]
      :answer_b: [[1, 2, 9, 21, 26, 28, 29, 45] and [16, 27, 34, 39, 40, 43, 46, 49]
      :answer_c: [21] and [1]
      :answer_d: [9] and [16]
      :feedback_a:  Первые два списка, которые будут слиты, представляют из себя базовый случай, а мы его ещё не достигли.
      :feedback_b: Это результат слияния двух последних списков.
      :feedback_c: Списки [21] и [1] - два первых базовых случая, с которыми сталкивается сортировка слиянием. Поэтому они будут первыми двумя слитыми списками.
      :feedback_d: Хотя 9 и 16 следуют друг за другом, они находятся в разных половиная списка, начиная с первого разбиения.

       Дан следующий список чисел:  [21, 1, 26, 45, 29, 28, 2, 9, 16, 49, 39, 27, 43, 34, 46, 40]. Какой ответ иллюстрирует первые два списка для слияния?
