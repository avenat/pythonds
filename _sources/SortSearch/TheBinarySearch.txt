..  Copyright (C)  Brad Miller, David Ranum, Jeffrey Elkner, Peter Wentworth, Allen B. Downey, Chris
    Meyers, and Dario Mitchell.  Permission is granted to copy, distribute
    and/or modify this document under the terms of the GNU Free Documentation
    License, Version 1.3 or any later version published by the Free Software
    Foundation; with Invariant Sections being Forward, Prefaces, and
    Contributor List, no Front-Cover Texts, and no Back-Cover Texts.  A copy of
    the license is included in the section entitled "GNU Free Documentation
    License".

Бинарный поиск
~~~~~~~~~~~~~~~

Существует возможность максимально использовать преимущества упорядоченного списка, если мы будем делать сравнения с умом. В последовательном поиске, когда мы сравниваем первый элемент, может быть до :math:`n-1` элемента, которые нужно просмотреть, если первый - не то, что мы ищем. Вместо того, чтобы искать в списке последовательно, **бинарный поиск** начинает проверять элементы с находящегося в середине. Если он является искомым - всё готово. Если нет, то мы можем использовать упорядоченную природу списка, исключив половину оставшихся элементов. Если искомое больше, чем находящийся по середине элемент, то из дальнейшего рассмотрения можно смело исключить "нижнюю" часть, содержащую меньшие элементы. Искомое значение (если оно есть в списке) будет находиться в "верхней" части.

Это рассуждение можно повторить для оставшейся половины. Начнём со среднего элемента и сравним его с искомым. Вновь, мы либо обнаружим его, либо разобьём список пополам, опять вычеркнув половину пространства для поиска. :ref:`Рисунок 3 <fig_binsearch>` показывает, как этот алгоритм быстро находит значение 54. Полностью функция показана в :ref:`CodeLens 3 <lst_binarysearchpy>`.

.. _fig_binsearch:

.. figure:: Figures/binsearch.png
   :align: center

Рисунок 3: Бинарный поиск в упорядоченном списке целых чисел

.. _lst_binarysearchpy:

.. codelens:: search3
    :caption: Бинарный поиск в упорядоченном списке

    def binarySearch(alist, item):
        first = 0
        last = len(alist)-1
        found = False

        while first<=last and not found:
            midpoint = (first + last)//2
            if alist[midpoint] == item:
                found = True
            else:
                if item < alist[midpoint]:
                    last = midpoint-1
                else:
                    first = midpoint+1

        return found

    testlist = [0, 1, 2, 8, 13, 17, 19, 32, 42,]
    print(binarySearch(testlist, 3))
    print(binarySearch(testlist, 13))

Перед тем, как перейти к анализу, отметим, что этот алгоритм - прекрасный пример стратегии "разделяй и властвуй". "Разделяй и властвуй" означает, что задача делится на маленькие участки, решаемые каким-то образом, а затем ответы компонуются в итоговый результат. Когда мы делаем бинарный поиск в списке, то в начале проверяем серединный элемент. Если искомое меньше его, то можно просто выполнить бинарный поиск для левой части оригинального списка. Аналогично, если искомое больше, то мы проводим бинарный поиск для правой половины. В обоих случаях присутствует рекурсивный вызов функции бинарного поиска на меньшем списке. :ref:`CodeLens 4 <lst_recbinarysearch>` демонстрирует эту рекурсивную версию.

.. _lst_recbinarysearch:

.. codelens:: search4
    :caption: Бинарный поиск - рекурсивный вариант

    def binarySearch(alist, item):
        if len(alist) == 0:
            return False
        else:
            midpoint = len(alist)//2
            if alist[midpoint]==item:
              return True
            else:
              if item<alist[midpoint]:
                return binarySearch(alist[:midpoint],item)
              else:
                return binarySearch(alist[midpoint+1:],item)

    testlist = [0, 1, 2, 8, 13, 17, 19, 32, 42,]
    print(binarySearch(testlist, 3))
    print(binarySearch(testlist, 13))
 

Анализ бинарного поиска
^^^^^^^^^^^^^^^^^^^^^^^^

Для анализа алгоритма бинарного поиска, нам необходимо вспомнить, что каждое сравнение исключает из рассмотрения около половины оставшихся элементов. Каково максимальное число сравнений, которые потребует алгоритм для проверки списка целиком? Если мы начинаем с *n* элементов, то после первого сравнения отбросится около :math:`\frac{n}{2}` элементов. После второго - порядка :math:`\frac{n}{4}`. Потом :math:`\frac{n}{8}`, :math:`\frac{n}{16}` и так далее. Сколько раз мы будем разделять список? :ref:`Таблица 3 <tbl_binaryanalysis>` поможет найти ответ.

.. _tbl_binaryanalysis:

.. table:: **Таблица 3: Табличный анализ для бинарного поиска**

    ======================== ===================================================== 
             **Сравнения**   **Приблизительное количество отброшенных элементов** 
    ======================== ===================================================== 
                           1                   :math:`\frac {n}{2}` 
                           2                   :math:`\frac {n}{4}` 
                           3                   :math:`\frac {n}{8}` 
                         ...                                        
                           i                 :math:`\frac {n}{2^i}` 
    ======================== ===================================================== 


Процесс разбиения закончится на списке, содержащем всего один элемент. Им может оказаться или не оказаться то, что мы ищем. В любом случае, дело сделано. Количество сравнений, необходимых до попадания в эту точку равно *i*, где :math:`\frac {n}{2^i} =1`. Решив уравнение для *i*, получаем :math:`i=\log n`. Максимальное количество сравнений является логарифмом по отношению к количеству элементов в списке. Таким образом, бинарный поиск будет :math:`O(\log n)`. 

Но нужно разобраться с ещё одним дополнительным вопросом по анализу. В рекурсивном решении, показанном выше, рекурсивный вызов ``binarySearch(alist[:midpoint],item)`` использует оператор среза, чтобы создать левую половину списка, которая затем будет передана следующему вызову (аналогично в случае правой половины). Анализ, проделанный выше, предполагает, что эта операция занимает константное время. Однако, мы знаем, что оператор среза в Python вообще-то *O(k)*. Таким образом, бинарный поиск, использующий срез, не будет выполняться за строго логарифмическое время. К счастью, это можно исправить, передавая кроме списка начальный и конечный индексы его элементов. Индексы могут быть вычислены, как мы делали в :ref:`листинге 3 <lst_binarysearchpy>`. Мы оставляем реализацию этой идеи в качестве упражнения.

Несмотря на то, что бинарный поиск в целом лучше последовательного, важно отметить, что при малых *n* дополнительные расходы на сортировку меньше не становятся. Фактически, мы всегда должны решать, насколько выгодно делать дополнительную работу по сортировке, чтобы воспользоваться преимуществами поиска. Если мы можем отсортировать список единожды, а потом искать в нём много раз, то цена сортировки значения не имеет. Однако, для больших списков даже единичная сортировка может быть настолько дорогой, что просто провести последовательный поиск от начала может стать наилучшим решением.

.. admonition:: Самопроверка

   .. mchoicemf:: BSRCH_1
      :correct: b
      :answer_a: 11, 5, 6, 8
      :answer_b: 12, 6, 11, 8
      :answer_c: 3, 5, 6, 8
      :answer_d: 18, 12, 6, 8
      :feedback_a:  Похоже, что вы ошиблись на единицу. Не забывайте, индекс первого элемента равен нулю.
      :feedback_b:  Бинарный поиск начинается с середины и каждый раз делит список пополам.
      :feedback_c: Бинарный поиск не начинается от начала списка и не проходит его последовательно. Он стартует с середины и делит список поплам после каждого сравнения.
      :feedback_d: Похоже, что вы начали с конца и делите список поплам каждый раз.

      Предположим, у вас есть следующий отсортированный список [3, 5, 6, 8, 11, 12, 14, 15, 17, 18], и вы используете алгоритм рекурсивного бинарного поиска. Какая группа чисел корректно отражает последовательность сравнений, используемых при поиске ключа 8?

   .. mchoicemf:: BSRCH_2
      :correct: d
      :answer_a: 11, 14, 17
      :answer_b: 18, 17, 15
      :answer_c: 14, 17, 15
      :answer_d: 12, 17, 15
      :feedback_a:  Похоже, что вы ошиблись на единицу. Не забывайте, индекс первого элемента равен нулю.
      :feedback_b:  Бинарный поиск начинается с середины и каждый раз делит список пополам.
      :feedback_c:  Похоже, что вы ошиблись на единицу.Будте аккуратны при высчитывании средней точки с использованием целочисленной арифметики.
      :feedback_d: Бинарный поиск начинается с середины и каждый раз делит список пополам. Он прекращает свою работу, когда список пуст.

       Предположим, у вас есть следующий отсортированный список [3, 5, 6, 8, 11, 12, 14, 15, 17, 18] и вы используете алгоритм рекурсивного бинарного поиска. Какая группа чисел корректно отражает последовательность сравнеий, используемых при поиске ключа 16?
