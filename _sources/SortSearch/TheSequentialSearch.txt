..  Copyright (C)  Brad Miller, David Ranum, Jeffrey Elkner, Peter Wentworth, Allen B. Downey, Chris
    Meyers, and Dario Mitchell.  Permission is granted to copy, distribute
    and/or modify this document under the terms of the GNU Free Documentation
    License, Version 1.3 or any later version published by the Free Software
    Foundation; with Invariant Sections being Forward, Prefaces, and
    Contributor List, no Front-Cover Texts, and no Back-Cover Texts.  A copy of
    the license is included in the section entitled "GNU Free Documentation
    License".

Последовательный поиск
~~~~~~~~~~~~~~~~~~~~~~~

Когда элементы данных хранятся коллекцией в виде списка, мы говорим, что они имеют линейные или последовательные отношения. Каждый элемент хранится на определённой позиции по отношению к остальным. В списках Python эта относительная позиция задаётся индексом данного элемента. Поскольку значения индексов упорядочены, мы имеем возможность последовательно проходить по ним. Этот процесс приводит к нашей первой поисковой технике - **последовательному поиску**.

:ref:`Рисунок 1 <fig_seqsearch>` демонстрирует, как работает такой поиск. Начиная с первого элемента в списке, мы просто движемся от элемента к элементу, следуя внутреннему порядку последовательности, до тех пор, пока либо не найдём то, что ищем, либо не достигнем последнего элемента. Во втором случае обнаружится, что последовательность не содержит то, что мы ищем.

.. _fig_seqsearch:

.. figure:: Figures/seqsearch.png
   :align: center

Рисунок 1: Последовательный поиск в списке целых чисел

Реализация этого алгоритма на Python показана в :ref:`CodeLens 1 <lst_seqsearchpython>`. Функция требует список и элемент, который мы ищем, а возвращает логическое значение, говорящее о его присутствии. Булева переменная ``found`` инициализируется значением ``False``, и если мы обнаруживаем элемент в списке, то присваиваем ей ``True``.

.. _lst_seqsearchpython:

.. codelens:: search1
    :caption: Последовательный поиск в неупорядоченном списке

    def sequentialSearch(alist, item):
        pos = 0
        found = False
        
        while pos < len(alist) and not found:
            if alist[pos] == item:
                found = True
            else:
                pos = pos+1

        return found

    testlist = [1, 2, 32, 8, 17, 19, 42, 13, 0]
    print(sequentialSearch(testlist, 3))
    print(sequentialSearch(testlist, 13))


Анализ последовательного поиска
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Для анализа алгоритма поиска нам нужно определиться с базовым блоком вычислений. Напомним, что обычно им является распространённый шаг, который будет повторяться с целью решения задачи. Для поиска имеет смысл подсчитывать количество производимых сравнений. Каждое сравнение может (или не может) обнаружить искомый элемент. В дополнение мы сделаем ещё одно предположение. Список элементов будет неупорядочен. Элементы размещаются в нём случайным образом. Другими словами, вероятность найти искомый элемент на данной позиции одинакова для всех индексов списка.

Если элемент не в списке, то единственный способ узнать это - сравнить его со всеми имеющимися значениями. Если имеется :math:`n` элементов, то последовательный поиск потребует :math:`n` сравнений, чтобы открыть отсутствие элемента. Если же элемент в списке присутствует, то анализ уже не столь очевиден. Вообще, есть три различных сценария. В лучшем случае мы найдём элемент на первой же позиции, которую рассмотрим, - в самом начале списка. Нам потребуется всего одно сравнение. В худшем случае мы будем искать элемент, пока не дойдём до самого последнего - n-го - сравнения.

Что можно сказать о среднем случае? В нём мы найдём элемент примерно на середине списка. Т.е. нам надо будет сравнить :math:`\frac{n}{2}` значения. Однако, напомним, что для больших *n* коэффициенты (вне зависимости от их величины) теряют значение в нашей аппроксимации. Так что сложность последовательного поиска равна :math:`O(n)`. :ref:`Таблица 1 <tbl_seqsearchtable>` суммирует результаты этих рассуждений:

.. _tbl_seqsearchtable:

.. table:: **Таблица 1: Сравнения, используемые в последовательном поиске в неупорядоченном списке**

    ==================== ========================== ========================== ========================
    **Вариант**           **Наилучший случай**       **Наихудший случай**       **Усреднённый случай**
    ==================== ========================== ========================== ========================
    Элемент присутствует      :math:`1`                  :math:`n`                  :math:`\frac{n}{2}`
    Элемент отсутствует       :math:`n`                  :math:`n`                  :math:`n`
    ==================== ========================== ========================== ========================


Ранее мы предполагали, что элементы в нашей последовательности размещены произвольно, так что между ними нет относительного упорядочения. Что произойдёт с последовательным поиском, если элементы будут каким-либо образом упорядочены? Сможем ли мы получить возможность для более эффективной методики поиска?

Предположим, что список занчений был построен таким образом, что они расположены в нём по возрастанию, от наименьшего к наибольшему. Если искомый элемент есть в списке, то вероятность для него быть на любой из *n* позиций такая же, как и раньше. Нам по-прежнему необходимо то же количество сравнений для поиска элемента. Однако, для случая, когда элемент в списке отсутствует, у нас есть небольшое преимущество. :ref:`Рисунок 2 <fig_seqsearch2>` показывает процесс поиска алгоритмом числа 50. Заметьте, что элементы сравниваются последовательно вплоть до 54. В этот момент у нас имеется некая дополнительная информация. Не только что 54 - не тот элемент, который мы ищем, но и что элементы за 54-м однозначно не подойдут, поскольку список отсортирован. В этом случае алгоритму нет смысла идти дальше и просматривать все элементы, чтобы сказать, что искомое не найдено. Он немедленно остановится. :ref:`CodeLens 2 <lst_seqsearchpython2>` показывает этот вариант функции последовательного поиска.

.. _fig_seqsearch2:

.. figure:: Figures/seqsearch2.png
   :align: center

Рисунок 2: Последовательный поиск в упорядоченном списке целых чисел.


.. _lst_seqsearchpython2:

.. codelens:: search2
    :caption: Последвательный поиск в упорядоченном списке

    def orderedSequentialSearch(alist, item):
        pos = 0
        found = False
        stop = False
        while pos < len(alist) and not found and not stop:
            if alist[pos] == item:
                found = True
            else:
                if alist[pos] > item:
                    stop = True
                else:
                    pos = pos+1

        return found

    testlist = [0, 1, 2, 8, 13, 17, 19, 32, 42,]
    print(orderedSequentialSearch(testlist, 3))
    print(orderedSequentialSearch(testlist, 13))

:ref:`Таблица 2 <tbl_seqsearchtable2>` суммирует эти результаты. Заметьте, в лучшем случае мы обнаружим, что элемент не в списке, просмотрев всего одно значение. В среднем мы будем это знать, просмотрев :math:`\frac {n}{2}` элементов. Однако, эта методика по-прежнему имеет :math:`O(n)`. Подводя итог, последвательный поиск улучшается с упорядочением списка только для случая, когда искомый элемент в нём отсутствует.

.. _tbl_seqsearchtable2:

.. table:: **Таблица 2: Количество сравнений при последовательном поиске в упорядоченном списке**


     ===================== ===================== =====================  ======================
							**Наилучший случай**  **Наихудший случай**  **Усреднённый случай**
     ===================== ===================== =====================  ======================
     Элемент присутствует  		:math:`1`        	:math:`n`     		  :math:`\frac{n}{2}`
     Элемент отсутствует 		:math:`1`        	:math:`n`     		  :math:`\frac{n}{2}`
     ===================== ===================== =====================  ======================

.. admonition:: Self Check

   .. mchoicemf:: question_SRCH_1
      :correct: d
      :answer_a: 5
      :answer_b: 10
      :answer_c: 4
      :answer_d: 2
      :feedback_a: Пять сравнений дадут вторую цифру 18 в списке.
      :feedback_b: Вам не нужно просматривать список целиком, только до тех пор, пока не найдёте искомое.
      :feedback_c: Вспомните, в последовательном поиске вы начинаете с начала и проверяете каждое значение, пока не найдёте то, что ищете, или список не закончится.
      :feedback_d: В этом случае потребуется всего два сравнения, чтобы найти искомое.

      Предположим, вы проводите последовательный поиск в списке [15, 18, 2, 19, 18, 0, 8, 14, 19, 14]. Сколько сравнений вам понадобится, чтобы найти ключ 18?

   .. mchoicemf:: question_SRCH_2
      :correct: c
      :answer_a: 10
      :answer_b: 5
      :answer_c: 7
      :answer_d: 6
      :feedback_a: Вам не нужно искать на всём списке. Так как он упорядочен, то вы можете остановить поиск, когда произойдёт сравнение со значением большим искомого.
      :feedback_b: Поскольку 11 меньше искомого 13, вам нужно продолжать поиск.
      :feedback_c: Поскольку 14 больше искомого 13, вы можете остановиться.
      :feedback_d: Поскольку 12 меньше искомого 13, вам нужно продолжать поиск.

       Предположим, вы проводите последовательный поиск в упорядоченном списке [3, 5, 6, 8, 11, 12, 14, 15, 17, 18]. Сколько сравнений вам потребуется, чтобы найти ключ 13?
