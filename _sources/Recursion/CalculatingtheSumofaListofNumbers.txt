..  Copyright (C)  Brad Miller, David Ranum, Jeffrey Elkner, Peter Wentworth, Allen B. Downey, Chris
    Meyers, and Dario Mitchell.  Permission is granted to copy, distribute
    and/or modify this document under the terms of the GNU Free Documentation
    License, Version 1.3 or any later version published by the Free Software
    Foundation; with Invariant Sections being Forward, Prefaces, and
    Contributor List, no Front-Cover Texts, and no Back-Cover Texts.  A copy of
    the license is included in the section entitled "GNU Free Documentation
    License".

Вычисление суммы списка чисел
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Начнём наше исследование с простой задачи, решение для которой вы уже знаете и без использования рекурсии. Предположим, вы хотите подсчитать сумму списка чисел :math:`[1, 3, 5, 7, 9]`. Решение в виде итеративной функции показано в :ref:`ActiveCode 1 <lst_itsum>`. Она использует переменную ``theSum`` в качестве аккумулятора, чьё начальное значение равно нулю и к которому прибавляются все числа из списка.


.. _lst_itsum:

.. activecode:: lst_itsum
    :caption: Итеративное суммирование

    def listsum(numList):
        theSum = 0
        for i in numList:
            theSum = theSum + i
        return theSum
        
    print(listsum([1,3,5,7,9])) 


Представьте на минуту, что вы не можете использовать циклы ``while`` или ``for``. Как бы вы подсчитали сумму чисел в списке? Если бы вы были математиками, то могли бы начать с того, что сложение - это функция, которая принимает два параметра (пару чисел). Чтобы переопределить задачу от сложения значений в списке к сложению пар чисел, мы перепишем список в виде выражения с полной расстановкой скобок. Выглядеть оно будет примерно так:

.. math::
    ((((1 + 3) + 5) + 7) + 9)

В прнципе, скобки можно расставить и в обратном порядке:

.. math::

     (1 + (3 + (5 + (7 + 9)))) 

Обратите внимание, что самое внутренне выражение в скобках - :math:`(7 + 9)` - это задача, которую можно решить без использования циклов или каких-то специальных конструкций. Фактически, мы можем использовать следующую последовательность упрощений для вычисления итоговой суммы:

.. math::

    total = \  (1 + (3 + (5 + (7 + 9)))) \\
    total = \  (1 + (3 + (5 + 16))) \\
    total = \  (1 + (3 + 21)) \\
    total = \  (1 + 24) \\
    total = \  25

Осталось только переписать эту идею в виде программы на Python. Для начала, давайте заново сформулируем задачу сложения в терминах списков Python. Мы можем сказать, что что сумма списка ``numList`` - это сумма первого его элемента (``numList[0]``) и уже посчитанной суммы остатка списка (``numList[1:]``). В виде функции это выглядит так:

.. math::

      listSum(numList) = first(numList) + listSum(rest(numList))
    \label{eqn:listsum}

В этом выражении :math:`first(numList)` возвращает первый элемент списка, а :math:`rest(numList)` - список из оставшихся чисел. Это легко выражается в коде (см. :ref:`ActiveCode 2 <lst_recsum>`):

.. _lst_recsum:

.. activecode:: lst_recsum
    :caption: Рекурсивное суммирование

    def listsum(numList):
       if len(numList) == 1:
            return numList[0]
       else:
            return numList[0] + listsum(numList[1:])
            
    print(listsum([1,3,5,7,9])) 

Из этого листинга можно извлечь несколько ключевых моментов. Во-первых, в строке 2 мы проверяем, не является ли список единичным. Эта проверка имеет решающее значение и является "лазейкой" из функции. Нахождение суммы единичного списка - тривиальная задача. Ею будет значение единственного его элемента. Во-вторых, в строке 5 функция вызывает саму себя! Вот почему мы называем алгоритм ``listsum`` рекурсивным. Рекурсивная функция - это функция, вызывающая саму себя.

На :ref:`рисунке 1 <fig_recsumin>` показана последовательность **рекурсивных вызовов**, которые требуются для подсчёта суммы списка :math:`[1, 3, 5, 7, 9]`. Вы можете думать о ней, как о серии упрощений. Каждый раз, когда мы делаем рекурсивный вызов, мы решаем задачу меньшего размера до тех пор пока не достигнем точки, в которой её нельзя будет уменьшить.

.. _fig_recsumin:

.. figure:: Figures/sumlistIn.png
   :align: center
   :alt: image

	Рисунок 1: Последовательность рекурсивных вызовов для сложения списка чисел.

Когда мы достигаем точки максимального упрощения задачи, то начинаем собирать вместе кусочки решения каждой из маленьких подзадач до тех пор, пока они не сольются в решение первоначальной задачи. :ref:`Рисунок 2 <fig_recsumout>` показывает операции сложения, которые выполняются во время работы ``listsum`` в обратном направлении по последовательности вызовов. Когда ```listsum``` вернёт ответ самой верхней задачи, мы будем иметь итоговое решение.

.. _fig_recsumout:

.. figure:: Figures/sumlistOut.png
   :align: center
   :alt: image

    Рисунок 2: Последовательность рекурсивных возвратов для сложения списка чисел.
