..  Copyright (C)  Brad Miller, David Ranum, Jeffrey Elkner, Peter Wentworth, Allen B. Downey, Chris
    Meyers, and Dario Mitchell.  Permission is granted to copy, distribute
    and/or modify this document under the terms of the GNU Free Documentation
    License, Version 1.3 or any later version published by the Free Software
    Foundation; with Invariant Sections being Forward, Prefaces, and
    Contributor List, no Front-Cover Texts, and no Back-Cover Texts.  A copy of
    the license is included in the section entitled "GNU Free Documentation
    License".

Три закона рекурсии
~~~~~~~~~~~~~~~~~~~~

Подобно роботам Азимова, все рекурсивные алгоритмы должны подчиняться трём важным законам:

#. Рекурсивный алгоритм должен иметь **базовый случай**.

#. Рекурсивный алгоритм должен изменять своё состояние и двигаться по направлению к базовому случаю.

#. Рекурсивный алгоритм должен вызывать сам себя.

Давайте рассмотрим каждый из этих законов более подробно и найдём их применение в алгоритме ``listsum``. Первый - базовый случай - это условие, которое позволяет алгоритму остановить рекурсию. Он представляет собой задачу настолько малую, что её можно решить без применения каких-то дополнительных средств. В алгоритме ``listsum`` базовый случай - это список длиной 1.

Чтобы соблюсти второй закон, мы должны организовать изменения состояния таким образом, чтобы алгоритм двигался по направлению к базовому случаю. Изменение состояния означает модификацию каких-то данных, используемых алгоритмом. Обычно объём данных, представленных в задаче, уменьшается каким-либо образом. В алгоритме ``listsum`` наша первоначальная структура данных - это список, так что следует сфокусировать усилия по изменению состояние на списке. Поскольку базовый случай - это список единичной длины, естественным прогрессом в его сторону будет сокращение списка. Это в точности то, что происходит в строке 5 :ref:`ActiveCode 2 <lst_recsum>`, когда мы вызываем ``listsum`` с более коротким списком.

Последний закон заключается в том, что алгоритм должен вызывать сам себя. Собственно, в этом и заключается определение рекурсии. Рекурсия - смущающая концепция для многих новичков-программистов. Как начинающий программист вы учили, что функции хороши тем, что позволяют взять большую задачу и разбить её на более мелкие части. Их можно решить, написав функцию для каждой. Когда же мы говорим о рекурсии, то может показаться, что мы собираемся зациклиться. У нас есть задача, решаемая с помощью функции, но для этого ей необходимо вызывать саму себя! Однако, логически здесь ничего не замкнуто: логика рекурсии в элегантном выражении решения задачи с помощью разбиения её на более мелкие и лёгкие подзадачи.

В конце этой части мы рассмотрим много примеров рекурсии. В каждом случае мы сфокусируемся на разработке решения задачи с помощью использования трёх законов рекурсии.


.. admonition:: Самопроверка

 .. mchoicemf:: question_recsimp_1
      :correct: c
      :answer_a: 6
      :answer_b: 5
      :answer_c: 4
      :answer_d: 3
      :feedback_a: В списке всего пять чисел. Количество рекурсивных вызовов не может превышать размер списка.
      :feedback_b: Первоначальный вызов ``listsum`` не считается рекурсивным.
      :feedback_c: первый рекурсивный вызов работает со списком [4,6,8,10], второй - с [6,8,10] и так далее до [10].
      :feedback_d: Недостаточно вызовов, чтобы охватить все числа в списке.

	Сколько рекурсивных вызовов делается в процессе подсчёта суммы списка [2,4,6,8,10]?

.. mchoicemf:: question_recsimp_2    
      :correct: d
      :answer_a: n == 0
      :answer_b: n == 1
      :answer_c: n &gt;= 0
      :answer_d: n &lt;= 1
      :feedback_a:  Несмотря на то, что это работает, существует более эффективный базовый случай, поскольку fact(1) и fact(0) возвращают одинаковый результат.
      :feedback_b: Хороший выбор, но что случится, если вы вызовете fact(0)?
      :feedback_c: Этот базовый случай верен для всех чисел больше нуля, т.е. ``fact`` любого положительного числа будет равен 1.
      :feedback_d: Прекрасно, этот вариант наиболее эффективен. Он обрушит вашу программу только в том случае, если вы попытаетесь вычислить факториал отрицательного числа.

	Предположим, вы собираетесь написать рекурсивную фунцию для подсчёта факториала числа. ``fact(n)`` возвращает ``n * (n-1) * (n-2)...`` Здесь факториал нуля по определению равен единице. Что будет подходящим базовым случаем?
