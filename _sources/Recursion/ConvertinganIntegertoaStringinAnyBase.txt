..  Copyright (C)  Brad Miller, David Ranum, Jeffrey Elkner, Peter Wentworth, Allen B. Downey, Chris
    Meyers, and Dario Mitchell.  Permission is granted to copy, distribute
    and/or modify this document under the terms of the GNU Free Documentation
    License, Version 1.3 or any later version published by the Free Software
    Foundation; with Invariant Sections being Forward, Prefaces, and
    Contributor List, no Front-Cover Texts, and no Back-Cover Texts.  A copy of
    the license is included in the section entitled "GNU Free Documentation
    License".

Конвертирование целого числа в строку по любому основанию
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Предположим, вы хотите преобразовать целое число в строку по какому-либо основанию между двойкой и шестнадцатью. Например, переведём число 10 в его строковое десятичное ``"10"`` или двоичное ``"1010"`` представление. Хотя существует множество алгоритмов для решения этой задачи (в том числе, алгоритм, обсуждавшийся в разделе о стеках), рекурсивная формулировка задания самая элегантная.

Давайте рассмотрим конкретный пример, используя основание 10 и число 769. Предположим, у нас есть последовательность символов, соответствующих первым десяти цифрам, - что-то вроде ``convString = "0123456789"``. Тогда конвертировать число, меньшее десяти, в его строковый эквивалент очень просто: достаточно всего лишь найти его в этом перечне. Например, для числа 9 строка будет ``convString[9]`` или ``"9"``. Если мы сможем организовать разбиение числа 769 на три цифры 7, 6 и 9, то конвертировать их будет просто. Вариант с числом меньше 10 очень подходит для базового случая рекурсии.

Зная наше основание, можно положить, что алгоритм в целом будет включать три компонента:

#. Разбить первоначальное число на последовательность из цифр.
#. Конвертировать каждое из них в строку с помощью поиска.
#. Слить получившиеся односимвольные строки в одну, которая и будет конечным результатом.

Следующий шаг - это придумать, как изменять состояние и продвигаться в строну базового случая. Поскольку мы работаем с числовыми значениями, то давайте рассмотрим, какие математические операции могут уменьшить число. Наиболее очевидными кандидатами будут деление и вычитание. Хотя последнее может работать, не совсем понятно, что из чего требуется вычитать. А вот деление нацело с получением остатка даёт нам чёткое направление. Давайте посмотрим, что произойдёт, если мы разделим число на основание, по которому пытаемся конвертировать.


Разделив 769 на 10 нацело, мы получим 76 и 9 в остатке. Это даст нам два хороших результата. Во-первых, остаток меньше нашего основания, следовательно, сразу же может быть преобразован в строку. Во-вторых, у нас есть число, меньшее первоначального и приближающееся к базовому случаю. Теперь наша задача - конвертировать 76 в строковое представление. Вновь использовав деление нацело, получим 7 и 6 в остатке. Наконец, задача свелась к конвертированию 7, что может быть легко сделано, поскольку удовлетворяет условию :math:`n < base` базового случая (:math:`base = 10`). Последовательность проделанных нами операций проиллюстрирована на :ref:`рисунке 3 <fig_tostr>`. Заметьте, что число, которое мы хотим запомнить, находится в коробочке остатка вдоль правого края диаграммы.

.. _fig_tostr:

.. figure:: Figures/toStr.png
   :align: center
   :alt: image

	Рисунок 3: Преобразование целого числа в строку по основанию 10.


:ref:`ActiveCode 3 <lst_rectostr>` демонстрирует код на Python, реализующий описанный выше алгоритм для любого основания между двойкой и шестнадцатью.


.. _lst_rectostr:

.. activecode:: lst_rectostr
    :caption: Рекурсивное конвертирование целого числа в строку

    def toStr(n,base):
       convertString = "0123456789ABCDEF"
       if n < base:
          return convertString[n]
       else:
          return toStr(n//base,base) + convertString[n%base]

    print(toStr(1453,16))
 

Обратите внимание, что в строке 3 мы проверяем базовый случай, в котором ``n`` должно быть меньше, чем основание, по которому мы конвертируем. Когда мы определяем базовый случай, то останавливаем рекурсию и просто возвращаем строку из последовательности ``convertString``. Строка 6 удовлетворяет требования второго и третьего законов: делает рекурсивный вызов и уменьшает размер задачи с помощью деления.


Давайте пройдём по алгоритму ещё раз. На этот раз мы будем конвертировать число 10 в его строковое представление по основанию 2 ("1010").

.. _fig_tostr2:

.. figure:: Figures/toStrBase2.png
   :align: center
   :alt: image

Рисунок 4: Преобразование числа 10 в строку по основанию 2.


:ref:`Рисунок 4 <fig_tostr2>` показывает, что мы получаем искомый результат, вот только цифры находятся в неверном порядке. Алгоритм работает правильно, потому что мы сначала делаем рекурсивный вызов в строке 6, а затем добавляем строковое представление остатка. Если мы поменяем местами возврат из поиска по ``convertString`` и возврат из вызова ``toStr``, то результирующая строка будет задом наперёд! Но если придержать операцию слияния до тех пор, пока не вернётся результат рекурсивного вызова, то ответ получит нужный порядок. Это должно напомнить вам наше обсуждение обратной работы стека в предыдущей главе.


.. admonition:: Самопроверка


Напишите функцию, которая принимает строку в качестве параметра и возвращает её же, но задом наперёд.

.. actex:: recursion_sc_1

      from test import testEqual
      def reverse(s):
          return s
      
      testEqual(reverse("hello"),"olleh")
      testEqual(reverse("l"),"l")      
      testEqual(reverse("follow"),"wollof")
      testEqual(reverse(""),"")

Напишите функцию, которая принимает строку в качестве параметра и возвращает истину в случае палиндрома, ложь - в обратном. Напомним, что строка является ппалиндромом, если одинаково читается справа налево и слева направо. Например, radar - это палиндром. Словосочетания тоже могут быть палиндромами, но прежде из них нужно удалить все пробелы и знаки препинания. Например, madam i’m adam - это палиндром. Вот ещё несколько забавных палиндромов:
* kayak
* aibohphobia
* Live not on evil
* Reviled did I live, said I, as evil I did deliver
* Go hang a salami; I’m a lasagna hog.
* Able was I ere I saw Elba
* Kanakanak – a town in Alaska
* Wassamassaw – a town in South Dakota

 .. actex:: recursion_sc_2

      from test import testEqual
      def removeWhite(s):
          return s

      def isPal(s):
          return False
      
      testEqual(isPal(removeWhite("x")),True)            
      testEqual(isPal(removeWhite("radar")),True)
      testEqual(isPal(removeWhite("hello")),False)
      testEqual(isPal(removeWhite("")),True)                  
      testEqual(isPal(removeWhite("hannah")),True)      
      testEqual(isPal(removeWhite("madam i'm adam")),True)
