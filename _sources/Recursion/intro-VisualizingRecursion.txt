..  Copyright (C)  Brad Miller, David Ranum, Jeffrey Elkner, Peter Wentworth, Allen B. Downey, Chris
    Meyers, and Dario Mitchell.  Permission is granted to copy, distribute
    and/or modify this document under the terms of the GNU Free Documentation
    License, Version 1.3 or any later version published by the Free Software
    Foundation; with Invariant Sections being Forward, Prefaces, and
    Contributor List, no Front-Cover Texts, and no Back-Cover Texts.  A copy of
    the license is included in the section entitled "GNU Free Documentation
    License".

Визуализация рекурсии
======================

В предыдущих разделах мы рассматривали задачи, которые могут быть легко решены с помощью рекурсии. Однако, найти ментальную модель или способ визуализации того, что происходит с рекурсивной функцией, по-прежнему непросто. Это делает рекурсию трудной для понимания. Поэтому в данном разделе мы рассмотрим несколько примеров использования рекурсии для рисования неких любопытных изображений. В процессе "прорисовки" этих картинок вы получите новое понимание рекурсивных процессов, что может быть полезным для закрепления вашего понимания рекурсии в целом.

Для наших иллюстраций мы воспользуемся графическим модулем Python под названием ``turtle``. Он входит в стандартный набор модулей для всех версий Python и очень прост в применении. Метафора, объясняющее его название (*turtle* (англ.) - черепаха) крайне проста: вы можете создать черепаху, которая умеет двигаться вперёд-назад, поворачивать направо-налево и т.п. У неё есть хвост, который она может поднимать или опускать. Когда черепаший хвост опущен и она движется, то он рисует линию. Чтобы увеличить художественную ценность черепахи, вы можете менять толщину хвоста и цвет чернил, в которые он был окрашен.

Вот простой пример, показывающий основы "черепашьего рисования". Мы используем модуль ``turtle``, чтобы рекурсивно нарисовать спираль. :ref:`ActiveCode 1 <lst_turt1>` показывает, как это делается. После подключения модуля ``turtle`` создаётся черепаху, вместе с которой появляется и окно для рисования. Потом мы определяем функцию ``drawSpiral``. Её базовым случаем будет момент, когда длина линии, которую мы хотим нарисовать (параметр ``len``), станет меньшей или равной нулю. Если же она больше нуля, то мы даём черепахе задание пройти ``len`` единиц, а затем повернуть на 90 градусов. Рекурсивным шагом будет вызов ``drawSpiral`` с уменьшенной длиной. В конце :ref:`ActiveCode 1 <lst_turt1>` вы увидитевызов функции ``myWin.exitonclick()``. Она управляет маленьким оконным методом, который переводит черепаху в режим ожидания до тех пор, пока вы не кликните внутри окна. После этого программа очистит полотно и закроется.

.. _lst_turt1:

.. activecode:: lst_turt1
    :caption: Рекурсивное рисование спирали с использованием черепахи

    import turtle

    myTurtle = turtle.Turtle()
    myWin = turtle.Screen()

    def drawSpiral(myTurtle, lineLen):
        if lineLen > 0:
            myTurtle.forward(lineLen)
            myTurtle.right(90)
            drawSpiral(myTurtle,lineLen-5)

    drawSpiral(myTurtle,100)
    myWin.exitonclick()

Вот и всё о "черепашьей графике", что вам нужно знать для рисования некоторых довольно впечатляющих картинок. В нашей следующей программе мы собираемся изобразить фрактальное дерево. Фракталы - это одна из ветвей математики, и они имеют с рекурсией много общего. Определение фрактала заключается в том, что вне зависимости от приближения он всегда содержит некоторую основную фигуру. Примерами из живой природы могут послужить береговые линии континентов, снежинки, горы и даже деревья или кустарники. Фрактальная природа этих объектов позволяет программистам генерировать очень реалистично выглядящие пейзажи для компьютерных изображений. Да и мы в следующем примере будем генерировать фрактальное дерево.

Чтобы понять, как всё это работает, полезно подумать над тем, как можно описать дерево, используя терминологию фракталов. Вспомните, что мы говорили выше: фрактал - это то, что выглядит одинаково на всех уровнях увеличения. Транслируя эту мысль на деревья и кустарники, можно сказать, что даже самая маленькая веточка имеет ту же форму и характеристики, что и целое дерево. Т.е. можно сказать, что *дерево* - это ствол от которого вправо и влево отходят меньшие *деревья*. Если вы подумете об этом определении, то поймёте, что его можно рекурсивно применить и для меньших правого и левого деревьев.

Давайте переведём эти мысли в код на Python. :ref:`Листинг 1 <lst_fractree>` демонстрирует, как мы можем использовать нашу черепаху для генерации фрактального дерева. Давайте посмотрим на код поближе. Вы можете видеть, что в строках 5 и 7 делаются рекурсивные вызовы. В строке 5 сразу после него черепаха поворачивает вправо на 20 градусов - это правое дерево. Затем в строке 7 вновь делается рекурсивный вызов, но в этот раз с поворотом влево на 40 градусов. Выбор такого числа связан с необходимостью скомпенсировать уже сделанный поворот на 20 градусов, а затем повернуть ещё на 20 влево с целью нарисовать левое дерево. Также обратите внимание, что при каждом рекурсивном вызове ``tree`` мы вычитаем из параметра ``branchLen`` некую величину. Это делается для того, чтобы рекурсивные деревья становились всё меньше и меньше. Вы также можете разобраться, что первоначальный оператор ``if`` в строке 2 проверяет базовый случай: ``branchLen`` стала слишком маленькой.

.. _lst_fractree:

**Листинг 1**


.. highlight:: python
    :linenothreshold: 5

::

    def tree(branchLen,t):
        if branchLen > 5:
            t.forward(branchLen)
            t.right(20)
            tree(branchLen-15,t)
            t.left(40)
            tree(branchLen-10,t)
            t.right(20)
            t.backward(branchLen)
            
            
.. highlight:: python
    :linenothreshold: 500

Полностью программа для примера с деревом показана в :ref:`ActiveCode 2 <lst_complete_tree>`. До того, как вы запустите её, подумайте: как должно выглядеть дерево? Посмотрите на рекурсивные вызовы и представьте, как оно будет разворачиваться. Будут ли его правая и левая части рисоваться симметрично и одновременно? Или сначала нарисуется правая, а затем левая половина?

.. _lst_complete_tree:

.. activecode:: lst_complete_tree
    :caption: Рекурсивное рисование дерева

    import turtle
    
    def tree(branchLen,t):
        if branchLen > 5:
            t.forward(branchLen)
            t.right(20)
            tree(branchLen-15,t)
            t.left(40)
            tree(branchLen-15,t)
            t.right(20)
            t.backward(branchLen)

    def main():
        t = turtle.Turtle()
        myWin = turtle.Screen()
        t.left(90)
        t.up()
        t.backward(100)
        t.down()
        t.color("green")
        tree(75,t)
        myWin.exitonclick()
        
    main()

Обратите внимание, что каждая точка разветвления соотносится с рекурсивным вызовом и как дерево прорисовывается вправо до самой короткой веточки. Вы можете это увидеть на :ref:`рисунке 1 <fig_tree1>`. А теперь обратите внимание, как программа работает в обратном направлении - к стволу, - когда нарисована вся правая часть. Вы можете увидеть правую половину дерева на :ref:`рисунке 2 <fig_tree2>`. Затем рисуется левая сторона дерева, но не от самой левой её части. Вместо этого вновь прорисовывается правая сторона левого дерева, и так до тех пор, пока не будет создана самая маленькая левая ветвь.


.. _fig_tree1:

.. figure:: Figures/tree1.png
   :align: center

   Рисунок 1: Начало фрактального дерева.
   
.. _fig_tree2:

.. figure:: Figures/tree2.png
   :align: center

   Рисунок 2: Первая половина фрактального дерева.


Эта простая программа - всего лишь точка отсчёта для вас. Легко заметить, что дерево не выглядит особенно реалистичным, поскольку природа не настолько симметрична, как компьютерные программы. Упражнения в конце этой главы подадут вам несколько идей для исследования интересных опций, позволяющих вашему дереву выглядеть более натурально.


.. admonition:: Самопроверка

  Измените программу для рекурсивного дерева, используя одну из следующих идей:


  - Измените толщину ветвей, чтобы при уменьшении ``branchLen`` линии становились тоньше.

  - Измените цвет ветвей таким образом, чтобы самые корокие ветви окрашивались как листья.

  - Измените угол поворота черепахи, чтобы каждая ветвь поворачивалась произвольным образом в некотором диапазоне. Например, выбирайте угол между 15-ю и 45-ю градусами. Поэкспрериментируйте в поисках лучшего вида.

  - Измените рекурсивную часть ``branchLen``, чтобы вместо вычитания постоянной величины кажый раз вычиталось произвольное значение из некоторого диапазона.

  .. actex:: recursion_sc_3
