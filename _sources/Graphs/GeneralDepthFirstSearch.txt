..  Copyright (C)  Brad Miller, David Ranum, Jeffrey Elkner, Peter Wentworth, Allen B. Downey, Chris
    Meyers, and Dario Mitchell.  Permission is granted to copy, distribute
    and/or modify this document under the terms of the GNU Free Documentation
    License, Version 1.3 or any later version published by the Free Software
    Foundation; with Invariant Sections being Forward, Prefaces, and
    Contributor List, no Front-Cover Texts, and no Back-Cover Texts.  A copy of
    the license is included in the section entitled "GNU Free Documentation
    License".

Поиск в глубину: общий случай
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Маршрут коня - особый случай поиска в глубину, целью которого является создание максимально высокого дерева без ветвей. Вообще, обычный поиск в глубину прост. Его задача - искать настолько глубоко, на сколько возможно, соединяя максимальное количество узлов графа с ветвлением только по необходимости.

Весьма вероятно, что поиск в глубину создаст больше, чем одно дерево. В этом случае мы называем их **лесом поиска в глубину**. Как и в поиске в ширину, здесь при создании дерева используется ссылка на предшественника. Также дополнительно требуются две новых поля в классе ``Vertex``: "время" входа и "время" выхода. Первое будет отслеживать, сколько шагов сделал алгоритм до того, как вершина была впервые обнаружена, а второе - количество шагов алгоритма до того, как вершину окрасили в чёрный цвет. В процессе изучения мы увидим, что оба "времени" обладают весьма любопытными свойствами, которые можно использовать в других алгоритмах.

Код нашего поиска в глубину показан в :ref:`листинге 5 <lst_dfsgeneral>`. Поскольку функции ``dfs`` и её помощница ``dfsvisit`` используют переменную для отслеживания "времени" в процессе вызовов ``dfsvisit``, мы выбрали реализацию кода как методов класса, наследующего классу ``Graph``. Она расширяет класс графа, добавляя атрибут ``time`` и два метода ``dfs`` и ``dfsvisit``. Если вы посмотрите на строку 11, то заметите, что метод ``dfs`` проходит по всем вершинам графа, вызывая ``dfsvisit`` на тех из них, которые открашены в белый. Причина, по которой мы проходим по всем узлам, заключается в том, что требуется выполнить не просто поиск из выбранного стартового узла, но и убедиться, что рассмотрены все вершины графа и ни одна из них не выпала из леса поиска. Оператор ``for aVertex in self`` может необычно смотреться, но вспомните, что в этом случае ``self`` - объект класса ``DFSGraph``. Поэтому проход по всем вершинам графа абсолютно естественнен.

.. highlight:: python
    :linenothreshold: 5

.. _lst_dfsgeneral:

**Листинг 5**

::

    from pythonds.graphs import Graph
    class DFSGraph(Graph):
        def __init__(self):
            super().__init__()
            self.time = 0

        def dfs(self):
            for aVertex in self:
                aVertex.setColor('white')
                aVertex.setPred(-1)
            for aVertex in self:
                if aVertex.getColor() == 'white':
                    self.dfsvisit(aVertex)

        def dfsvisit(self,startVertex):
            startVertex.setColor('gray')
            self.time += 1
            startVertex.setDiscovery(self.time)
            for nextVertex in startVertex.getConnections():
                if nextVertex.getColor() == 'white':
                    nextVertex.setPred(startVertex)
                    self.dfsvisit(nextVertex)
            startVertex.setColor('black')
            self.time += 1
            startVertex.setFinish(self.time)

.. highlight:: python
    :linenothreshold: 500

Хотя нашу реализацию ``bfs`` интересовало рассмотрение только тех узлов, через которые существует путь от стартовой точки, возможно создать лес поиска в ширину, который представлял бы кратчайшие пути между всеми парами узлов в графе. Мы оставляем это задание в качестве упражнения. А из следующих двух алгоритмов станет ясно, отчего так важно отслеживать лес поиска в глубину.

Метод ``dfsvisit`` начинает работу с единичной вершины ``startVertex`` и исследует всех её соседей, окрашенных в белый, настолько глубоко, насколько это возможно. Если вы внимательно посмотрите на код ``dfsvisit`` и сравните его с поиском в ширину, то заметите, что эти два алгоритма во многом похожи, за исключением последней строки вложенного цикла ``for``. В ней ``dfsvisit`` вызывает сама себя, чтобы продолжить поиск на более глубоком уровне, в то время как ``bfs`` добавляет узел в очередь для дальнейшего исследования. Интересно заметить, что там где ``bfs`` использует очередь, ``dfsvisit`` пользуется стеком. Вы не видите его в коде, но он неявно присутствует в рекурсивном вызове ``dfsvisit``.

Следующая последовательность рисунков иллюстрирует работу алгоритма поиска в глубину для небольшого графа. Пунктирные линии обозначают уже проверенные рёбра, но узлы на другом их конце уже добавлены в дерево поиска. В коде этот тестируется проверкой, что цвет другого узла - не белый.

Поиск начинается с вершины А (:ref:`рисунок 14 <fig_gdfsa>`). Поскольку все узлы в начале поиска окрашены в белый, её алгоритм посещает. Первый шаг при посещении узла - окрасить его в серый (вершина была исследована) и установить "время" входа равным единице. Поскольку А имеет две смежные вершины (B, D), то каждую из них тоже требуется посетить. Мы принимаем произвольное решение заходить в узлы в алфавитном порядке.

Следующей посещаем вершину B (:ref:`рисунок 15 <fig_gdfsb>`). Её цвет устанавливается серым, а "время" входа равным 2. Этот узел также имеет два смежных (C, D), поэтому далее мы посещаем узел С - в соответствии с алфавитом.

Визит в C (:ref:`рисунок 16 <fig_gdfsc>`) приводит нас к концу ветки дерева. После окрашивания её в серый и присвоения "времени" входа 3, алгоритм находит отсутствие у С смежных вершин. Это означает, что мы завершили её исследование, так что можно окрасить С в чёрный и задать ей "время" выхода равным 4. Состояние поиска на данный момент вы можете видеть на :ref:`рисунке 17 <fig_gdfsd>`.

Поскольку С является концом первой ветви, мы возвращаемся в вершину B и продолжаем исследовать смежные с ней узлы. Единственная дополнительная вершина для исследования из В - это D, так что мы посещаем её (:ref:`рисунок 18 <fig_gdfse>`) и продолжаем поиск уже из D. Эта вершина быстро приводит нас в E (:ref:`рисунок 19 <fig_gdfsf>`). Узел Е имеет два смежных - B и F. Обычно мы исследовали их в алфавитном порядке, но сейчас В уже окрашен в серый. Алгоритм распознаёт, что ему не следует туда заходить, чтобы не загнать себя в цикл. Поэтому исследование продолжается для следующей вершины из списка - F (:ref:`рисунок 20 <fig_gdfsg>`).

F имеет единственный смежный узел - С. Но поскольку он уже окрашена в чёрный, то больше исследовать нечего, и алгоритм достигает конца другой ветви. Отсюда вы можете видеть на :ref:`рисунках с 21-го <fig_gdfsh>` по :ref:`25-й <fig_gdfsl>`, как алгоритм возвращается обратно к первому узлу, устанавливает ему "время" выхода и окрашивает его в чёрный.

.. _fig_gdfsa:

.. figure:: Figures/gendfsa.png
   :align: center

   Рисунок 14: Создание дерева поиска в глубину - 10
   
.. _fig_gdfsb:

.. figure:: Figures/gendfsb.png
   :align: center
   
   Рисунок 15: Создание дерева поиска в глубину - 11
          
.. _fig_gdfsc:

.. figure:: Figures/gendfsc.png
   :align: center

   Рисунок 16: Создание дерева поиска в глубину - 12
   
.. _fig_gdfsd:

.. figure:: Figures/gendfsd.png
   :align: center

   Рисунок 17: Создание дерева поиска в глубину - 13
   
.. _fig_gdfse:

.. figure:: Figures/gendfse.png
   :align: center

   Рисунок 18: Создание дерева поиска в глубину - 14
   
.. _fig_gdfsf:

.. figure:: Figures/gendfsf.png
   :align: center

   Рисунок 19: Создание дерева поиска в глубину - 15

.. _fig_gdfsg:

.. figure:: Figures/gendfsg.png
   :align: center

   Рисунок 20: Создание дерева поиска в глубину - 16
   
.. _fig_gdfsh:

.. figure:: Figures/gendfsh.png
   :align: center

   Рисунок 21: Создание дерева поиска в глубину - 17
   
.. _fig_gdfsi:

.. figure:: Figures/gendfsi.png
   :align: center

   Рисунок 22: Создание дерева поиска в глубину - 18
   
.. _fig_gdfsj:

.. figure:: Figures/gendfsj.png
   :align: center

   Рисунок 23: Создание дерева поиска в глубину - 19
   
.. _fig_gdfsk:

.. figure:: Figures/gendfsk.png
   :align: center

   Рисунок 24: Создание дерева поиска в глубину - 20
   
.. _fig_gdfsl:

.. figure:: Figures/gendfsl.png
   :align: center

   Рисунок 25: Создание дерева поиска в глубину - 21

"Времена" входа и выхода для каждого узла показывают так называемое **свойство скобок**. Оно означает, что все потомки данного узла в дереве поиска имеют более позднее "время" входа и раннее "время" выхода, чем их предки. :ref:`Рисунок 26 <fig_dfstree>` показывает дерево, сконструированное алгоритмом поиска в глубину.

.. _fig_dfstree:


.. figure:: Figures/dfstree.png
   :align: center
   
   Рисунок 26: Результирующее дерево поиска в глубину
