..  Copyright (C)  Brad Miller, David Ranum, Jeffrey Elkner, Peter Wentworth, Allen B. Downey, Chris
    Meyers, and Dario Mitchell.  Permission is granted to copy, distribute
    and/or modify this document under the terms of the GNU Free Documentation
    License, Version 1.3 or any later version published by the Free Software
    Foundation; with Invariant Sections being Forward, Prefaces, and
    Contributor List, no Front-Cover Texts, and no Back-Cover Texts.  A copy of
    the license is included in the section entitled "GNU Free Documentation
    License".

Сильно связные компоненты
---------------------------

В оставшейся части этой главы мы обратим наше внимание на очень большие графы. Чтобы изучить несколько дополнительных алгоритмов, будем использовать графы связей между хостами в интернете и ссылок между веб-страницами.

Поисковые системы вроде Google и Bing используют в своих интересах тот факт, что страницы в вебе образуют очень большой направленный граф. Чтобы преобразовать в него Всемирную Паутину, мы будем рассматривать страницы, как вершины, а гиперссылки между ними - как соединяющие их рёбра. :ref:`Рисунок 30 <fig_cshome>` демонстрирует очень маленькую часть графа, получившегося из ссылок от одной страницы к другой со стартовой точкой на домашней странице Luther College’s Computer Science. Конечно, этот граф был бы огромным, так что мы ограничили его сайтами, на которых есть не более десяти ссылок с домашней страницы CS.

.. _fig_cshome:

.. figure:: Figures/cshome.png
   :align: center

   Рисунок 30: Граф из ссылок с домашней страницы Luther Computer Science 

Если вы изучите граф на :ref:`рисунке 30 <fig_cshome>`, то сможете сделать несколько любопытных наблюдений. Во-первых, многие из веб-сайтов графа - прочие сайты Luther College. Во-вторых, в графе присутствует несколько ссылок на колледж в Айове. В-третьих, в графе имеется несколько ссылок на другие гуманитарные колледжи. Из этого можно сделать заключение, что здесь присутствует некая внутренняя структура, объединяющая вместе сайты, в чём-то похожие друг на друга.

Один из алгоритмов, помогающих найти кластеры из сильно связных вершин графа, называется алгоритмом поиска сильно связных компонентов (**SCC** - от англ. *strongly connected components*). Формально мы можем определить **сильно связную компоненту**, :math:`C` графа :math:`G`, как наибольшее подмножество вершин :math:`C \subset V` таких, что для каждой пары вершин :math:`v, w \in C` существует путь от :math:`v` до :math:`w` и от :math:`w` до :math:`v`. На :ref:`рисунке 27 <fig_scc1>` показан простой граф с тремя сильно связными компонентами, которые выделены разными затенёнными областями.

.. _fig_scc1:
        
.. figure:: Figures/scc1.png
   :align: center

   Рисунок 31: Направленный граф с тремя сильно связными компонентами

После определения сильно связных компонент, мы можем показать упрощённый вид графа, собрав все вершины каждой из них в одну большую. Упрощённая версия графа с :ref:`рисунка 31 <fig_scc1>` показана на :ref:`рисунке 32 <fig_scc2>`.

.. _fig_scc2:

.. figure:: Figures/scc2.png
   :align: center

   Рисунок 32: Упрощённый граф

Вновь мы видим, что, используя поиск в глубину, можем создать очень мощный и эффективный алгоритм. Однако, прежде нужно рассмотреть ещё одно определение. **Транспозиция** графа :math:`G` определяется, как граф :math:`G^T`, у которого все рёбра имеют обратное направление. Т.е., если в оригинальном графе ребро направлено из узла А в узел В, то :math:`G^T` будет содержать ребро из узла В в узел А.

:ref:`Рисунки 33 <fig_tpa>` и :ref:`34 <fig_tpb>` демонстрируют простой граф и его транспозицию.

.. _fig_tpa:


.. figure:: Figures/transpose1.png
   :align: center

   Figure 33: Граф :math:`G`
          
.. _fig_tpb:


.. figure:: Figures/transpose2.png
   :align: center

   Figure 34: Его транспозиция :math:`G^T`

Посмотрите ещё раз на рисунки. Обратите внимание, что граф на :ref:`рисунке 33 <fig_tpa>` имеет две сильно связные компоненты. А теперь взгляните на :ref:`рисунок 34 <fig_tpb>`. На нём так же изображены две сильно связные компоненты.

Теперь мы можем описать алгоритм вычисления SCC в графе.

#. Вызвать ``dfs`` для графа :math:`G`, чтобы вычислить "времена" выхода каждой вершины.

#. Вычислить :math:`G^T`.

#. Вызвать ``dfs`` для графа :math:`G^T`, но в основном цикле DFS исследовать каждую вершину в порядке убывания "времени" выхода.

#. Каждое дерево из леса, найденного на шаге 3, будет сильно связной компонентой. Для её идентификации осталось вывести id каждого узла всех деревьев в лесу.

Давайте пошагово проследим описанные выше пункты для графа на :ref:`рисунке 31 <fig_scc1>`. :ref:`Рисунок 35 <fig_sccalga>` показывает "времена" входа и выхода, вычисленные для оригинального графа с помощью алгоритма DFS. На :ref:`рисунке 36 <fig_sccalgb>` показаны они же, но вычисленные для транспозиции графа.

 .. _fig_sccalga:

.. figure:: Figures/scc1a.png
   :align: center
   
   Рисунок 35: "Времена" выхода для графа :math:`G`  
     
.. _fig_sccalgb:

.. figure:: Figures/scc1b.png
   :align: center
   
   Рисунок 36: "Времена" выхода для :math:`G^T`

Наконец, на :ref:`рисунке 37 <fig_sccforest>` показан лес из трёх деревьев, созданный на третьем шаге SCC алгоритмом. Заметьте, что мы не даём вам код на Python для этого алгоритма, поскольку его написание остаётся в качестве упражнения.

.. _fig_sccforest:

.. figure:: Figures/sccforest.png
   :align: center
