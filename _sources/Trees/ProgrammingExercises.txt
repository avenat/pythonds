..  Copyright (C)  Brad Miller, David Ranum, Jeffrey Elkner, Peter Wentworth, Allen B. Downey, Chris
    Meyers, and Dario Mitchell.  Permission is granted to copy, distribute
    and/or modify this document under the terms of the GNU Free Documentation
    License, Version 1.3 or any later version published by the Free Software
    Foundation; with Invariant Sections being Forward, Prefaces, and
    Contributor List, no Front-Cover Texts, and no Back-Cover Texts.  A copy of
    the license is included in the section entitled "GNU Free Documentation
    License".

Упражнения для программирования
--------------------------------

#. Расширьте функцию ``buildParseTree``, чтобы она могла работать с математическими выражениями, в которых нет пробелов между каждым символом.

#. Измените функции ``buildParseTree`` и ``evaluate``, чтобы они могли работать с логическими операторами (и, или, не). Помните, "не" - унарный оператор, что некоторым образом усложняет ваш код.

#. Используя метод ``findSuccessor``, напишите нерекурсивный симметричный обход двоичного дерева поиска.

#. Измените код для двоичного дерева поиска, чтобы сделать его потоковым. Напишите нерекурсивный симметричный метод обхода для такого дерева. Потоковое двоичное дерево поддерживает в каждом узле ссылку на его преемника.

#. Измените нашу реализацию двоичного дерева поиска, чтобы оно правильно работало с дубликатами ключей. Т.е., если ключ в дереве уже присутствует, то новая полезная нагрузка заменяет старую, вместо того, чтобы добавлять новый узел с тем же ключом.

#. Создайте двоичную кучу с ограниченным размером. Другими словами, куча может отслеживать только ``n`` важных элементов. Если её размер становится больше, то наименее приоритетный элемент отбрасывается.

#. Почистите функцию ``printexp``, чтобы она не расставляла дополнительные наборы скобок вокруг каждого числа.

#. Используя метод ``buildHeap``, напишите сортировочную функцию, которая будет работать за время :math:`O(n\log{n})`.

#. Напишите функцию, которая принимает дерево синтаксического разбора математического выражения и вычисляет его производную по отношению к некоторой переменной.

#. Реализуйте двоичную кучу как max heap.

#. Используя класс ``BinaryHeap``, реализуйте новый класс ``PriorityQueue``. Он должен содержать конструктор и методы ``enqueue`` и ``dequeue``.
