..  Copyright (C)  Brad Miller, David Ranum, Jeffrey Elkner, Peter Wentworth, Allen B. Downey, Chris
    Meyers, and Dario Mitchell.  Permission is granted to copy, distribute
    and/or modify this document under the terms of the GNU Free Documentation
    License, Version 1.3 or any later version published by the Free Software
    Foundation; with Invariant Sections being Forward, Prefaces, and
    Contributor List, no Front-Cover Texts, and no Back-Cover Texts.  A copy of
    the license is included in the section entitled "GNU Free Documentation
    License".

Дерево синтаксического разбора
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Закончив с реализацией дерева как структуры данных, рассмотрим примеры его применения при решении некоторых реальных задач. Этот раздел будет посвящён деревьям синтаксического разбора. Они могут использоваться для представления таких конструкций реального мира, как предложения естественного языка или математические выражения.

.. _fig_nlparse:

.. figure:: Figures/nlParse.png
   :align: center
   :alt: image

   Рисунок 1: Дерево синтаксического разбора простого предложения

На :ref:`рисунке 1 <fig_nlparse>` изображена иерархическая структура простого предложения. Такое представление позволяет нам работать с его отдельными частями, используя поддеревья.

.. _fig_meparse:

.. figure:: Figures/meParse.png
   :align: center
   :alt: image

   Рисунок 2: Дерево синтаксического разбора выражения :math:`((7+3)*(5-2))`

Также можно представить в виде дерева синтаксического разбора математическое выражение наподобие :math:`((7 + 3) * (5 - 2))` (см. :ref:`рисунок 2 <fig_meparse>`). Мы уже рассматривали выражения с полной расстановкой скобок; исходя из этого, что можно сказать о данном примере? Нам известно, что умножение имеет более высокий приоритет, чем сложение и вычитание. Благодаря скобкам мы знаем, что перед умножением нужно вычислить сумму и разность. Иерархия дерева помогает лучше понять порядок вычисления выражения целиком. Перед тем, как найти находящееся на самом верху произведение, нужно провести сложение и вычитание в поддеревьях. Сложение - левое поддерево - даст 10, вычитание - правое поддерево - 3. Используя свойство иерархической структуры, мы можем просто заменить каждое из поддеревьем на узел, содержащий вычисленный ответ. Процедура замены даст нам упрощённое дерево, показанное на :ref:`рисунке 3 <fig_mesimple>`.

.. _fig_mesimple:

.. figure:: Figures/meSimple.png
   :align: center
   :alt: image

   Рисунок 3: Упрощённое дерево синтаксического разбора для :math:`((7+3)*(5-2))`

До конца этого раздела мы собираемся детально протестировать деревья синтаксического разбора. Точнее, мы рассмотрим:

- Как построить дерево разбора для математического выражения с полной расстановкой скобок.

- Как вычислить выражение, хранящееся в дереве разбора.

- Как записать оригинальное математическое выражение из дерева разбора.

Первый шаг при постороении дерева синтаксического разбора - это разбить строку выражения на список токенов. Их насчитывается четыре вида: левая скобка, правая скобка, оператор и операнд. Мы знаем, что прочитанная левая скобка всегда означает начало нового выражения и, следовательно, необходимо создать связанное с ним новое дерево. И наоборот, когда мы считываем правую скобку, мы завершаем выражение. Так же известно, что операнды будут листьями и потомками своих операторов. Наконец, мы знаем, что каждый оператор имеет как правого, так и левого потомков.

Используя перечисленную выше информацию, определим следующие правила:

#. Если считанный токен ``'('`` - добавляем новый узел, как левого потомка текущего узла, и спускаемся по нему вниз.

#. Если считанный токен - один из элементов списка ``['+','-','/','*']``, то устанавливаем корневое значение текущего узла равным оператору из этого токена. Добавляем новый узел на место правого потомка текущего и спускаемся вниз по правому поддереву.

#. Если считанный токен - число, то устанавливаем корневое значение равным этой величине и возвращаемся к родителю.

#. Если считанный токен - ``')'``, то перемещаемся к родителю текущего узла.

Перед тем, как писать код на Python, давайте рассмотрим в живую приведённые выше правила. Мы будем работать с выражением :math:`(3 + (4 * 5))` и разобьём его следующим образом: ``['(', '3', '+', '(', '4', '*', '5' ,')',')']``. Начинать будем с дерева разбора, содержащего пустой корневой узел. :ref:`Рисунок 4 <fig_bldExpstep>` демонстрирует структуру и содержимое дерева разбора по мере того, как вычисляется каждый новый токен.

.. _fig_bldExpstep:

.. figure:: Figures/buildExp1.png
   :align: center
   :alt: image



.. figure:: Figures/buildExp2.png
   :align: center
   :alt: image



.. figure:: Figures/buildExp3.png
   :align: center
   :alt: image



.. figure:: Figures/buildExp4.png
   :align: center
   :alt: image


.. figure:: Figures/buildExp5.png
   :align: center
   :alt: image


.. figure:: Figures/buildExp6.png
   :align: center
   :alt: image


.. figure:: Figures/buildExp7.png
   :align: center
   :alt: image


.. figure:: Figures/buildExp8.png
   :align: center
   :alt: image

   Рисунок 4: Трассировка постороения дерева разбора.

Используя этот рисунок, пройдём по примеру шаг за шагом.

а) Создаём пустое дерево.

б) Читаем ``(`` в качестве первого токена. По правилу 1, создаём новый узел, как левого потомка корня. Делаем текущим этот новый узел.

в) Считываем следующий токен - ``3``. По правилу 3 устанавливаем значение текущего узла в ``3`` и перемещаемся обратно к родителю.

г) Следующим считываем ``+``. По правилу 2 устанавливаем корневое значение текущего узла в ``+`` и добавляем ему правого потомка. Этот новый узел становится текущим.

д) Считываем ``(``. По правилу 1 создаём для текущего узла левого потомка. Этот новый узел становится текущим.

е) Считываем ``4``. По правилу 3 устанавливаем значение текущего узла равным ``4``. Делаем текущим узлом родителя ``4``.

ж) Считываем следующий токен - ``*``. По правилу 2 устанавливаем корневое значение текущего узла равным ``*`` и создаём его правого потомка. Он становится текущим.

з) Считываем ``5``. По правилу 3 устанавливаем корневое значение текущего узла в ``5``, после чего текущим становится его родитель.

и) Считываем ``)``. По правилу 4 делаем текущим узлом родителя ``*``.

к) Наконец, считываем последний токен - ``)``. По правилу 4 мы должны сделать текущим родителя ``+``. Но такого узла не существует, следовательно, мы закончили.

Из примера выше очевидно, что необходимо отслеживать не только текущий узел, но и его родителя. Интерфейс дерева предоставляет нам способы получить потомков заданного узла - с помощью методов ``getLeftChild`` и ``getRightChild``, - но как нам отследить родителя? Простым решением для этого станет использование стека в процессе прохода по дереву. Перед тем, как спуститься к потомку узла, мы кладём его в стек. Когда же надо будет вернуть родителя текущего узла, мы вытолкнем из стека нужный узел.

Используя описанные выше правила совместно с операциями из ``Stack`` и ``BinaryTree``, мы готовы написать на Python функцию для создания дерева синтаксического разбора. Код её представлен в :ref:`ActiveCode 1 <lst_buildparse>`.

.. _lst_buildparse:

.. activecode::  parsebuild
    :caption: Постороение дерева синтаксического разбора

    from pythonds.basic.stack import Stack
    from pythonds.trees.binaryTree import BinaryTree

    def buildParseTree(fpexp):
        fplist = fpexp.split()
        pStack = Stack()
        eTree = BinaryTree('')
        pStack.push(eTree)
        currentTree = eTree
        for i in fplist:
            if i == '(':            
                currentTree.insertLeft('')
                pStack.push(currentTree)
                currentTree = currentTree.getLeftChild()
            elif i not in ['+', '-', '*', '/', ')']:  
                currentTree.setRootVal(int(i))
                parent = pStack.pop()
                currentTree = parent
            elif i in ['+', '-', '*', '/']:       
                currentTree.setRootVal(i)
                currentTree.insertRight('')
                pStack.push(currentTree)
                currentTree = currentTree.getRightChild()
            elif i == ')':          
                currentTree = pStack.pop()
            else:
                raise ValueError
        return eTree

    pt = buildParseTree("( ( 10 + 5 ) * 3 )")
    pt.postorder()  #определено и объясняется в следующем разделе

Четыре правила для постороения дерева разбора закодированы в первых четырёх ``if``-ах в строках 11, 15, 19 и 24 :ref:`ActiveCode 1 <lst_buildparse>`. В каждом случае вы можете видеть код, воплощающий правило, как оно описано выше, с помощью нескольких вызовов методов ``BinaryTree`` или ``Stack``. Единственная ошибка, которую мы проверяем в этой функции - это ветка ``else``, вызывающая исключение ``ValueError``, если мы получаем токен, который не можем рапознать.

Итак, дерево синтаксического разбора построено, но что с ним теперь делать? В качестве первого примера, напишем функцию, вычисляющую дерево разбора и возвращающую числовой результат. Для этого используем иерархическу природу дерева. Посмотрите ещё раз на :ref:`рисунок 2 <fig_meparse>`. Напомним, что мы можем заменить оригинальное дерево упрощённым, показанным на :ref:`рисунке 3 <fig_mesimple>`. Это предполагает, что можно написать алгоритм, вычисляющий дерево разбора с помощью рекурсивного вычисления каждого из его поддеревьев.

Как мы уже делали для рекурсивных алгоритмов в прошлом, написание функции начнём с выявления базового случая. Естественным базовым случаем для рекурсивных алгоритмов, работающих с деревьями, является проверка узла на лист. В дереве разбора такими узлами всегда будут операнды. Поскольку объекты, подобные целым или действительным числам, не требуют дальнейшей интерпретации, функция ``evaluate`` может просто возвращать значение, сохранённое в листе дерева. Рекурсивный шаг, продвигающий функцию к базовому случаю, будет вызывать ``evaluate`` для правого и левого потомков текущего узла. Так мы эффективно спустимся по дереву до его листьев.

Чтобы собрать вместе результаты двух рекурсивных вызовов, мы просто применим к ним сохранённый в родительском узле оператор. В примере на :ref:`рисунке 3 <fig_mesimple>` мы видим, что два потомка корневого узла выисляются в 10 и 3. Применение оператора умножения даст нам окончательный результат, равный 30.

Код рекурсивной функции ``evaluate`` показан в :ref:`листинге 1 <lst_eval>`. Сначала мы получаем ссылки на правого и левого потомков текущего узла. Если оба они вычисляются в ``None``, значит этот узел - лист. Это проверяется в строке 7. Если же узел не листовой, то ищем в нём оператор и применяем его к результатам рекурсивных вычислений левого и правого потомков.

Для реализации арифметики мы используем словарь с ключами ``'+', '-', '*'`` и ``'/'``. Хранимые в нём значения - функции из модуля операторов Python. Этот модуль предоставляет в наше распоряжение множество часто употребляемых операторов в виде функций. Когда мы ищем в словаре оператор, извлекается связанный с ним функциональный объект. А поскольку этот объект - функция, мы можем вызвать её обычным способом ``function(param1, param2)``. Таким образом, поиск ``opers['+'](2,2)`` эквивалентен ``operator.add(2,2)``.

.. _lst_eval:

**Листинг 1**

.. highlight:: python
    :linenothreshold: 5

::

    def evaluate(parseTree):
        opers = {'+':operator.add, '-':operator.sub, '*':operator.mul, '/':operator.truediv}
             
        leftC = parseTree.getLeftChild()
        rightC = parseTree.getRightChild()
        
        if leftC and rightC:
            fn = opers[parseTree.getRootVal()]
            return fn(evaluate(leftC),evaluate(rightC))
        else:
            return parseTree.getRootVal()


.. highlight:: python
    :linenothreshold: 500

Наконец, проследим работу функции ``evaluate`` на дереве синтаксического разбора, которое изображено на :ref:`рисунке 4 <fig_bldExpstep>`. В первом вызове ``evaluate`` мы передаём ей корень всего дерева в качестве параметра ``parseTree``. Затем получаем ссылки на левого и правого потомков, чтобы убедиться в их существовании. В строке 9 идёт следующий рекурсивный вызов. Мы начинаем с поиска оператора в корне дерева, которым в данном случае является ``+``. Он отображается как вызов функции ``operator.add``, принимающей два параметра. Традиционно для вызова функции первым, что сделает Python, будет вычисление переданных в функцию параметров. В нашем случае оба они - рекурсивные вызовы ``evaluate``. Вычисляя слева направо, сначала выполнится левый рекурсивный вызов, куда передано левое поддерево. Мы обнаружим, что этот узел не имеет потомков, следовательно, является листом. Поэтому мы просто вернём хранящееся в нём значение, как результат вычисления. В данном случае им окажется целое число 3.

К этому моменту у нас есть один параметр, вычисленный для верхнего вызова ``operator.add``. Но мы ещё не закончили. Продолжая вычислять параметры слева направо, мы делаем рекурсивный вызов для правого поддерева корня. Обнаружив, что у него есть и правый, и левый потомки, ищем оператор, хранящийся в узле, (``'*'``) и вызываем для него функцию, передавая в неё левого и правого потомков в качестве параметров. В этой точке вычисления оба рекурсивных вызова вернут листья - целые 4 и 5, соответственно. Имея их, вернём результат ``operator.mul(4,5)``. Теперь у нас есть все операнды для верхнего оператора ``+``, и всё, что остаётся, - это вызвать ``operator.add(3,20)``. Результат вычисления дерева для выражения :math:`(3 + (4 * 5))` равен 23.
