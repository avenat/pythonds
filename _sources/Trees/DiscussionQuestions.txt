..  Copyright (C)  Brad Miller, David Ranum, Jeffrey Elkner, Peter Wentworth, Allen B. Downey, Chris
    Meyers, and Dario Mitchell.  Permission is granted to copy, distribute
    and/or modify this document under the terms of the GNU Free Documentation
    License, Version 1.3 or any later version published by the Free Software
    Foundation; with Invariant Sections being Forward, Prefaces, and
    Contributor List, no Front-Cover Texts, and no Back-Cover Texts.  A copy of
    the license is included in the section entitled "GNU Free Documentation
    License".

Вопросы для обсуждения
-----------------------

#. Нарисуйте дерево, которое будет результатом следующего перечня вызовов функций:

::

       >>> r = BinaryTree(3)
       >>> insertLeft(r,4)
       [3, [4, [], []], []]
       >>> insertLeft(r,5)
       [3, [5, [4, [], []], []], []]
       >>> insertRight(r,6)
       [3, [5, [4, [], []], []], [6, [], []]]
       >>> insertRight(r,7)
       [3, [5, [4, [], []], []], [7, [], [6, [], []]]]
       >>> setRootVal(r,9)
       >>> insertLeft(r,11)
       [9, [11, [5, [4, [], []], []], []], [7, [], [6, [], []]]]

#. Сделайте трассировку алгоритма для создания дерева из выражения :math:`(4 * 8) / 6 - 3`.

#. Рассмотрим следующий список целых чисел: [1,2,3,4,5,6,7,8,9,10]. Покажите двоичное дерево поиска, получающееся в результате вставки чисел в список.

#. Рассмотрим следующий список целых чисел: [10,9,8,7,6,5,4,3,2,1]. Покажите двоичное дерево поиска, получающееся в результате вставки чисел в список.

#. Сгенерируйте список из случайных целых чисел. Покажите двоичное дерево кучи, получающееся в результате их вставки в список по одному.

#. Используя список из предыдущего вопроса, покажите двоичное дерево кучи, получающееся в результате использования списка в качестве параметра метода ``buildHeap``. Продемонстрируйте обе формы: в виде списка и в виде дерева.

#. Нарисуйте двоичное дерево поиска, которое будет результатом вставки следующих ключей в заданном порядке: 68,88,61,89,94,50,4,76,66 и 82.

#. Сгенерируйте список случайных целых чисел. Нарисуйте двоичное дерево поиска, получающееся в результате их вставки в список.

#. Рассмотрим следующий список: [1,2,3,4,5,6,7,8,9,10]. Покажите двоичную кучу, которая будет результатом вставки чисел по одному за раз.

#. Рассмотрим следующий список: [10,9,8,7,6,5,4,3,2,1]. Покажите двоичную кучу, которая будет результатом вставки чисел по одному за раз.

#. Рассмотрите две различные техники, которые мы использовали для реализации проходов по двоичному дереву. Почему мы делаем проверку перед вызовом ``preorder``, когда реализуем метод, хотя для функции она происходит внутри?

#. Покажите функциональные вызовы, необходимые для построения следующего двоичного дерева:

.. figure:: Figures/exerTree.png
        :align: center

#. Выполните соответствующие вращения для заданного дерева, чтобы привести его в сбалансированное состояние.

.. figure:: Figures/rotexer1.png
         :align: center

#. Используя следующий рисунок, как стартовую точку, выведите уравнение, дающее обновление фактора сбалансированности для узла D.

.. figure:: Figures/bfderive.png
         :align: center
